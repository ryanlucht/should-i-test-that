---
phase: 05-advanced-mode
plan: 04
type: tdd
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/calculations/sample-size.ts
  - src/lib/calculations/sample-size.test.ts
  - src/lib/calculations/cost-of-delay.ts
  - src/lib/calculations/cost-of-delay.test.ts
  - src/lib/calculations/evsi.ts
  - src/lib/calculations/evsi.test.ts
  - src/lib/calculations/types.ts
  - src/lib/calculations/index.ts
autonomous: true

must_haves:
  truths:
    - "deriveSampleSizes returns n_total, n_control, n_variant from experiment design"
    - "calculateCostOfDelay returns CoD only when default decision is Ship"
    - "calculateEVSI returns EVSI via Monte Carlo for Student-t/Uniform priors"
    - "calculateEVSINormalFastPath returns EVSI in O(1) for Normal priors"
    - "Feasibility bounds reject samples where CR1 outside [0,1]"
  artifacts:
    - path: "src/lib/calculations/sample-size.ts"
      provides: "Sample size derivation functions"
      exports: ["deriveSampleSizes"]
    - path: "src/lib/calculations/cost-of-delay.ts"
      provides: "Cost of Delay calculation"
      exports: ["calculateCostOfDelay"]
    - path: "src/lib/calculations/evsi.ts"
      provides: "EVSI calculation (Monte Carlo + Normal fast path)"
      exports: ["calculateEVSIMonteCarlo", "calculateEVSINormalFastPath"]
    - path: "src/lib/calculations/types.ts"
      provides: "Type definitions for EVSI inputs/results"
      contains: "EVSIInputs"
  key_links:
    - from: "src/lib/calculations/evsi.ts"
      to: "src/lib/calculations/distributions.ts"
      via: "import sample, cdf"
      pattern: "import.*sample.*cdf.*from.*distributions"
    - from: "src/lib/calculations/cost-of-delay.ts"
      to: "src/lib/calculations/derived.ts"
      via: "deriveK"
      pattern: "import.*deriveK"
---

<objective>
Implement EVSI calculation engine, sample size derivation, and Cost of Delay using TDD approach.

Purpose: Core calculation logic for Advanced mode - EVSI quantifies test value, CoD penalizes waiting per ADV-CALC-01 through ADV-CALC-07.
Output: Working calculation modules with comprehensive tests, ready for Web Worker integration.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-advanced-mode/05-CONTEXT.md
@.planning/phases/05-advanced-mode/05-RESEARCH.md
@src/lib/calculations/evpi.ts (pattern reference)
@src/lib/calculations/statistics.ts
@src/lib/calculations/derived.ts
@src/lib/calculations/types.ts
</context>

<feature>
  <name>Sample Size Derivation</name>
  <files>src/lib/calculations/sample-size.ts, src/lib/calculations/sample-size.test.ts</files>
  <behavior>
    deriveSampleSizes(inputs) -> { n_total, n_control, n_variant }

    Per SPEC.md A3.3:
    - n_total = dailyTraffic * testDurationDays * eligibilityFraction
    - n_variant = n_total * variantFraction
    - n_control = n_total - n_variant

    Test cases:
    - 1000 daily, 14 days, 100% eligible, 50% split -> n_total=14000, n_variant=7000, n_control=7000
    - 1000 daily, 14 days, 50% eligible, 50% split -> n_total=7000, n_variant=3500, n_control=3500
    - 1000 daily, 14 days, 100% eligible, 30% split -> n_total=14000, n_variant=4200, n_control=9800
    - Fractional results should be floored
  </behavior>
  <implementation>
    Create sample-size.ts:
    1. Define SampleSizeInputs interface
    2. Define SampleSizeResults interface
    3. Implement deriveSampleSizes with floor for integer counts
    4. Add comments explaining formula derivation
  </implementation>
</feature>

<feature>
  <name>Cost of Delay Calculation</name>
  <files>src/lib/calculations/cost-of-delay.ts, src/lib/calculations/cost-of-delay.test.ts</files>
  <behavior>
    calculateCostOfDelay(inputs) -> { codDollars, dailyOpportunityCost, codApplies }

    Per SPEC.md A6:
    - EV_ship_annual = K * (mu_L - T_L)
    - EV_ship_day = EV_ship_annual / 365
    - If default is Ship (EV_ship_annual > 0):
      CoD = (1 - f_var) * EV_ship_day * D_test + EV_ship_day * D_latency
    - If default is Don't Ship:
      CoD = 0, codApplies = false

    Test cases:
    - K=1,000,000, mu_L=0.05, T_L=0, D_test=14, f_var=0.5, D_latency=2 -> codApplies=true, CoD > 0
    - K=1,000,000, mu_L=-0.02, T_L=0 -> codApplies=false, CoD=0 (default is Don't Ship)
    - D_test=0, D_latency=0 -> CoD=0 (no delay)
    - f_var=1.0 (100% variant) -> only decision latency contributes to CoD
  </behavior>
  <implementation>
    Create cost-of-delay.ts:
    1. Define CoDInputs interface with K, mu_L, threshold_L, testDurationDays, variantFraction, decisionLatencyDays
    2. Define CoDResults interface
    3. Implement calculateCostOfDelay following SPEC formula
    4. Handle Don't Ship case (return 0, codApplies=false)
    5. Add detailed comments explaining CoD intuition
  </implementation>
</feature>

<feature>
  <name>EVSI Calculation (Monte Carlo + Normal Fast Path)</name>
  <files>src/lib/calculations/evsi.ts, src/lib/calculations/evsi.test.ts, src/lib/calculations/types.ts</files>
  <behavior>
    calculateEVSIMonteCarlo(inputs, numSamples=5000) -> EVSIResults
    calculateEVSINormalFastPath(inputs) -> EVSIResults

    EVSIResults: { evsiDollars, defaultDecision, probabilityClearsThreshold, probabilityTestChangesDecision }

    Per SPEC.md A4-A5:
    Monte Carlo algorithm:
    1. For each sample i:
       a. Sample L_i from prior
       b. Feasibility check: reject if CR1 = CR0*(1+L) outside [0,1]
       c. Calculate value without test (based on default decision)
       d. Simulate observed lift (L_true + noise, where noise ~ N(0, SE))
       e. Make posterior decision (ship if L_observed >= threshold)
       f. Calculate value with test
    2. EVSI = avg(value_with_test) - avg(value_without_test)

    Normal fast path (ADV-CALC-07):
    - Uses conjugate Normal-Normal update for O(1) calculation
    - posterior_precision = prior_precision + data_precision
    - Pre-posterior sigma determines EVSI

    Test cases:
    - EVSI should be non-negative
    - EVSI <= EVPI for same inputs (EVSI is bounded by EVPI)
    - Normal fast path should match Monte Carlo within tolerance (~5%)
    - Student-t with df=30 should be close to Normal
    - Uniform prior with wide bounds should have higher EVSI
    - Zero sample size -> EVSI = 0 (no information)
    - Feasibility: low CR0 with fat-tailed prior should reject some samples
  </behavior>
  <implementation>
    Update types.ts:
    1. Add EVSIInputs interface extending from PriorDistribution
    2. Add EVSIResults interface

    Create evsi.ts:
    1. Import sample, cdf, getPriorMean from distributions
    2. Import standardNormalPDF, standardNormalCDF from statistics
    3. Implement helper: sampleStandardNormal (Box-Muller)
    4. Implement calculateEVSIMonteCarlo:
       - Main loop with feasibility rejection
       - SE calculation from sample sizes and CR0
       - Value calculation for with/without test scenarios
    5. Implement calculateEVSINormalFastPath:
       - Closed-form posterior update
       - Pre-posterior sigma calculation
       - EVSI formula similar to EVPI but with pre-posterior sigma
    6. Add comprehensive comments explaining Bayesian pre-posterior analysis
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: TDD Sample Size Derivation</name>
  <files>src/lib/calculations/sample-size.ts, src/lib/calculations/sample-size.test.ts</files>
  <action>
    RED: Write failing tests for deriveSampleSizes covering:
    - Standard case (1000 daily, 14 days, 100%, 50%)
    - Partial eligibility
    - Non-50/50 split
    - Edge case: very small numbers

    GREEN: Implement deriveSampleSizes to pass tests
    REFACTOR: Clean up if needed, ensure comments are clear

    Export from index.ts
  </action>
  <verify>`npm test -- sample-size` passes</verify>
  <done>Sample size derivation complete with tests.</done>
</task>

<task type="auto">
  <name>Task 2: TDD Cost of Delay</name>
  <files>src/lib/calculations/cost-of-delay.ts, src/lib/calculations/cost-of-delay.test.ts</files>
  <action>
    RED: Write failing tests for calculateCostOfDelay covering:
    - Ship decision with positive CoD
    - Don't Ship decision (CoD = 0)
    - Zero duration (CoD = 0)
    - 100% variant split (only latency contributes)
    - Verify formula matches SPEC.md A6

    GREEN: Implement calculateCostOfDelay to pass tests
    REFACTOR: Ensure comments explain CoD intuition

    Export from index.ts
  </action>
  <verify>`npm test -- cost-of-delay` passes</verify>
  <done>Cost of Delay calculation complete with tests.</done>
</task>

<task type="auto">
  <name>Task 3: TDD EVSI Calculation</name>
  <files>src/lib/calculations/evsi.ts, src/lib/calculations/evsi.test.ts, src/lib/calculations/types.ts</files>
  <action>
    Update types.ts with EVSIInputs and EVSIResults interfaces.

    RED: Write failing tests for EVSI covering:
    - Normal prior: fast path vs Monte Carlo consistency (~5% tolerance)
    - EVSI non-negative
    - EVSI <= EVPI for same prior
    - Student-t prior returns valid result
    - Uniform prior returns valid result
    - Zero sample size returns EVSI ~= 0
    - Feasibility rejection with low CR0 and fat tails

    GREEN: Implement calculateEVSIMonteCarlo and calculateEVSINormalFastPath
    - Use seedrandom in tests for deterministic results
    - Default numSamples = 5000 for production, lower for tests

    REFACTOR: Optimize loop if needed, ensure comments are comprehensive

    Export from index.ts
  </action>
  <verify>`npm test -- evsi` passes</verify>
  <done>EVSI calculation complete with Monte Carlo and Normal fast path.</done>
</task>

</tasks>

<verification>
Run all calculation tests:
```bash
npm test -- src/lib/calculations
```

Verify exports:
```bash
npm run typecheck
```

All tests must pass. Types must be exported correctly from index.
</verification>

<success_criteria>
- deriveSampleSizes returns correct values for various inputs
- calculateCostOfDelay returns CoD only when default is Ship
- calculateEVSIMonteCarlo produces valid EVSI for all prior shapes
- calculateEVSINormalFastPath matches Monte Carlo for Normal priors
- Feasibility bounds properly enforced (CR1 in [0,1])
- All tests pass
- All functions exported from calculations/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-advanced-mode/05-04-SUMMARY.md`
</output>
