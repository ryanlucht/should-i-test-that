---
phase: 05-advanced-mode
plan: 05
type: execute
wave: 3
depends_on: ["05-01", "05-04"]
files_modified:
  - src/lib/workers/evsi.worker.ts
  - src/hooks/useEVSICalculations.ts
  - src/hooks/useEVSICalculations.test.ts
autonomous: true

must_haves:
  truths:
    - "EVSI calculation runs in Web Worker without blocking UI"
    - "Normal priors use fast path (no Worker needed)"
    - "Hook returns loading state while Worker is computing"
    - "Hook returns null when inputs are incomplete"
    - "Hook returns EVSIResults + CoDResults when calculation completes"
  artifacts:
    - path: "src/lib/workers/evsi.worker.ts"
      provides: "Web Worker for EVSI Monte Carlo calculation"
      exports: ["computeEVSI"]
    - path: "src/hooks/useEVSICalculations.ts"
      provides: "React hook for Advanced mode calculations"
      exports: ["useEVSICalculations"]
  key_links:
    - from: "src/hooks/useEVSICalculations.ts"
      to: "src/lib/workers/evsi.worker.ts"
      via: "Comlink Worker import"
      pattern: "new ComlinkWorker"
    - from: "src/lib/workers/evsi.worker.ts"
      to: "src/lib/calculations/evsi.ts"
      via: "import calculation functions"
      pattern: "import.*calculateEVSI"
---

<objective>
Create Web Worker for EVSI computation and React hook that orchestrates Advanced mode calculations.

Purpose: Non-blocking EVSI calculation per ADV-CALC-03 (500ms-2s target), unified hook interface for Advanced mode.
Output: Working Web Worker with Comlink, useEVSICalculations hook with loading state.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-advanced-mode/05-CONTEXT.md
@.planning/phases/05-advanced-mode/05-RESEARCH.md
@.planning/phases/05-advanced-mode/05-01-SUMMARY.md (for Comlink setup)
@.planning/phases/05-advanced-mode/05-04-SUMMARY.md (for EVSI functions)
@src/hooks/useEVPICalculations.ts (pattern reference)
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EVSI Web Worker</name>
  <files>src/lib/workers/evsi.worker.ts</files>
  <action>
    Create src/lib/workers/evsi.worker.ts:

    ```typescript
    /**
     * EVSI Web Worker
     *
     * Offloads Monte Carlo EVSI computation to background thread.
     * Uses Comlink for type-safe RPC communication.
     *
     * Per 05-RESEARCH.md:
     * - Normal priors use fast path (closed-form, no Monte Carlo)
     * - Student-t and Uniform use Monte Carlo (~5000 samples)
     * - Target performance: 500ms-2s
     */

    import {
      calculateEVSIMonteCarlo,
      calculateEVSINormalFastPath,
    } from '../calculations/evsi';
    import type { EVSIInputs, EVSIResults } from '../calculations/types';

    /**
     * Compute EVSI - exposed via Comlink
     *
     * Selects fast path for Normal priors, Monte Carlo otherwise.
     *
     * @param inputs - EVSI calculation inputs
     * @param numSamples - Monte Carlo samples (ignored for Normal)
     * @returns EVSI results
     */
    export async function computeEVSI(
      inputs: EVSIInputs,
      numSamples: number = 5000
    ): Promise<EVSIResults> {
      if (inputs.prior.type === 'normal') {
        // Fast path: closed-form for Normal prior (O(1))
        return calculateEVSINormalFastPath(inputs);
      }

      // Monte Carlo for Student-t and Uniform priors
      return calculateEVSIMonteCarlo(inputs, numSamples);
    }

    // Note: vite-plugin-comlink automatically wraps exports
    // No manual Comlink.expose() needed
    ```

    Create directory if needed: src/lib/workers/
  </action>
  <verify>
    - File compiles without errors
    - `npm run typecheck` passes
    - `npm run build` completes (Worker bundled correctly)
  </verify>
  <done>
    EVSI Web Worker created with Comlink integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useEVSICalculations hook</name>
  <files>src/hooks/useEVSICalculations.ts</files>
  <action>
    Create src/hooks/useEVSICalculations.ts following useEVPICalculations pattern:

    ```typescript
    /**
     * EVSI Calculations Hook
     *
     * React hook for Advanced mode calculations.
     * Computes EVSI (via Web Worker for non-Normal), CoD, and Net Value.
     *
     * Key behaviors:
     * - Returns null if inputs incomplete or mode is 'basic'
     * - Returns loading=true while Worker is computing
     * - Uses fast path for Normal priors (no Worker needed)
     * - Derives sample sizes from experiment design
     * - Calculates CoD from experiment parameters
     *
     * Per 05-CONTEXT.md: Results show EVSI - CoD, not EVPI.
     */

    import { useState, useEffect, useMemo } from 'react';
    import { useWizardStore } from '@/stores/wizardStore';
    import {
      deriveSampleSizes,
      calculateCostOfDelay,
      calculateEVSINormalFastPath,
      deriveK,
      normalizeThresholdToLift,
    } from '@/lib/calculations';
    import { computePriorFromInterval, DEFAULT_PRIOR, DEFAULT_INTERVAL } from '@/lib/prior';
    import { getPriorMean } from '@/lib/calculations/distributions';
    import type { EVSIResults, CoDResults } from '@/lib/calculations/types';
    import type { PriorDistribution } from '@/lib/calculations/distributions';

    // Import worker with Comlink (vite-plugin-comlink provides typing)
    // Lazy-load to avoid Worker creation on initial render
    let workerPromise: Promise<typeof import('../lib/workers/evsi.worker')> | null = null;

    function getWorker() {
      if (!workerPromise) {
        workerPromise = import('../lib/workers/evsi.worker?worker').then(
          (mod) => mod.default
        );
      }
      return workerPromise;
    }

    export interface EVSICalculationsResult {
      evsi: EVSIResults;
      cod: CoDResults;
      netValueDollars: number;  // max(0, EVSI - CoD)
      sampleSizes: { n_total: number; n_control: number; n_variant: number };
    }

    export interface UseEVSICalculationsReturn {
      results: EVSICalculationsResult | null;
      isLoading: boolean;
      error: Error | null;
    }

    /**
     * Hook for EVSI calculations in Advanced mode
     */
    export function useEVSICalculations(): UseEVSICalculationsReturn {
      const mode = useWizardStore((state) => state.mode);
      const sharedInputs = useWizardStore((state) => state.inputs.shared);
      const advancedInputs = useWizardStore((state) => state.inputs.advanced);

      const [results, setResults] = useState<EVSICalculationsResult | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);

      // Memoize derived values to avoid recalculation
      const derivedValues = useMemo(() => {
        // Must be in advanced mode
        if (mode !== 'advanced') return null;

        // Validate shared inputs
        if (
          sharedInputs.baselineConversionRate === null ||
          sharedInputs.annualVisitors === null ||
          sharedInputs.valuePerConversion === null ||
          sharedInputs.thresholdScenario === null
        ) {
          return null;
        }

        // Validate advanced inputs
        if (
          advancedInputs.testDurationDays === null ||
          advancedInputs.dailyTraffic === null
        ) {
          return null;
        }

        // For non-any-positive threshold, need value and unit
        if (
          sharedInputs.thresholdScenario !== 'any-positive' &&
          (sharedInputs.thresholdValue === null || sharedInputs.thresholdUnit === null)
        ) {
          return null;
        }

        // Derive K
        const K = deriveK(
          sharedInputs.annualVisitors,
          sharedInputs.baselineConversionRate,
          sharedInputs.valuePerConversion
        );

        // Derive threshold in lift units
        let threshold_L: number;
        if (sharedInputs.thresholdScenario === 'any-positive') {
          threshold_L = 0;
        } else {
          threshold_L = normalizeThresholdToLift(
            sharedInputs.thresholdValue!,
            sharedInputs.thresholdUnit!,
            K
          );
        }

        // Build prior distribution
        let prior: PriorDistribution;
        const priorShape = advancedInputs.priorShape ?? 'normal';

        // Get interval bounds (use defaults if not set)
        const isDefaultPrior =
          sharedInputs.priorIntervalLow !== null &&
          sharedInputs.priorIntervalHigh !== null &&
          Math.abs(sharedInputs.priorIntervalLow - DEFAULT_INTERVAL.low) < 0.01 &&
          Math.abs(sharedInputs.priorIntervalHigh - DEFAULT_INTERVAL.high) < 0.01;

        const intervalParams = isDefaultPrior ||
          sharedInputs.priorIntervalLow === null ||
          sharedInputs.priorIntervalHigh === null
          ? DEFAULT_PRIOR
          : computePriorFromInterval(
              sharedInputs.priorIntervalLow,
              sharedInputs.priorIntervalHigh
            );

        if (priorShape === 'uniform') {
          // For Uniform, interval bounds ARE the distribution bounds
          prior = {
            type: 'uniform',
            low_L: (sharedInputs.priorIntervalLow ?? DEFAULT_INTERVAL.low) / 100,
            high_L: (sharedInputs.priorIntervalHigh ?? DEFAULT_INTERVAL.high) / 100,
          };
        } else if (priorShape === 'student-t') {
          prior = {
            type: 'student-t',
            mu_L: intervalParams.mu_L,
            sigma_L: intervalParams.sigma_L,
            df: advancedInputs.studentTDf ?? 5,  // Default to moderate tails
          };
        } else {
          // Normal
          prior = {
            type: 'normal',
            mu_L: intervalParams.mu_L,
            sigma_L: intervalParams.sigma_L,
          };
        }

        // Derive sample sizes
        const sampleSizes = deriveSampleSizes({
          dailyTraffic: advancedInputs.dailyTraffic,
          testDurationDays: advancedInputs.testDurationDays,
          eligibilityFraction: advancedInputs.eligibilityFraction ?? 1,
          variantFraction: advancedInputs.trafficSplit ?? 0.5,
        });

        return {
          K,
          threshold_L,
          prior,
          sampleSizes,
          baselineCR: sharedInputs.baselineConversionRate,
          testDurationDays: advancedInputs.testDurationDays,
          variantFraction: advancedInputs.trafficSplit ?? 0.5,
          decisionLatencyDays: advancedInputs.decisionLatencyDays ?? 0,
        };
      }, [mode, sharedInputs, advancedInputs]);

      // Run EVSI calculation when derived values change
      useEffect(() => {
        if (!derivedValues) {
          setResults(null);
          setIsLoading(false);
          return;
        }

        const {
          K,
          threshold_L,
          prior,
          sampleSizes,
          baselineCR,
          testDurationDays,
          variantFraction,
          decisionLatencyDays,
        } = derivedValues;

        // Build EVSI inputs
        const evsiInputs = {
          K,
          threshold_L,
          prior,
          n_control: sampleSizes.n_control,
          n_variant: sampleSizes.n_variant,
          baselineCR,
        };

        // Calculate CoD (synchronous - fast)
        const cod = calculateCostOfDelay({
          K,
          mu_L: getPriorMean(prior),
          threshold_L,
          testDurationDays,
          variantFraction,
          decisionLatencyDays,
        });

        // For Normal prior, use fast path (no Worker needed)
        if (prior.type === 'normal') {
          try {
            const evsi = calculateEVSINormalFastPath(evsiInputs);
            const netValueDollars = Math.max(0, evsi.evsiDollars - cod.codDollars);
            setResults({ evsi, cod, netValueDollars, sampleSizes });
            setIsLoading(false);
            setError(null);
          } catch (err) {
            setError(err instanceof Error ? err : new Error(String(err)));
            setResults(null);
            setIsLoading(false);
          }
          return;
        }

        // For non-Normal, use Web Worker
        setIsLoading(true);
        setError(null);

        // Use dynamic import for Worker
        import('../lib/workers/evsi.worker?worker')
          .then((workerModule) => {
            // Create worker instance
            const worker = new workerModule.default();
            return worker.computeEVSI(evsiInputs, 5000);
          })
          .then((evsi) => {
            const netValueDollars = Math.max(0, evsi.evsiDollars - cod.codDollars);
            setResults({ evsi, cod, netValueDollars, sampleSizes });
          })
          .catch((err) => {
            setError(err instanceof Error ? err : new Error(String(err)));
            setResults(null);
          })
          .finally(() => {
            setIsLoading(false);
          });

        // No cleanup needed - Worker terminates on its own
      }, [derivedValues]);

      return { results, isLoading, error };
    }
    ```

    NOTE: The Worker import pattern may need adjustment based on vite-plugin-comlink specifics.
    Use `?worker` suffix for Vite native worker imports if Comlink wrapper has issues.
  </action>
  <verify>
    - `npm run typecheck` passes
    - Hook compiles without errors
  </verify>
  <done>
    useEVSICalculations hook created with Worker integration and loading state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test useEVSICalculations hook</name>
  <files>src/hooks/useEVSICalculations.test.ts</files>
  <action>
    Create tests for useEVSICalculations:

    ```typescript
    /**
     * Tests for useEVSICalculations hook
     *
     * Note: Worker tests may need mocking since Vitest doesn't
     * natively support Web Workers in JSDOM environment.
     */

    import { describe, it, expect, vi, beforeEach } from 'vitest';
    import { renderHook, waitFor } from '@testing-library/react';
    import { useEVSICalculations } from './useEVSICalculations';
    import { useWizardStore } from '@/stores/wizardStore';

    // Mock the Worker module
    vi.mock('../lib/workers/evsi.worker?worker', () => ({
      default: class MockWorker {
        computeEVSI = vi.fn().mockResolvedValue({
          evsiDollars: 5000,
          defaultDecision: 'ship',
          probabilityClearsThreshold: 0.6,
          probabilityTestChangesDecision: 0.3,
        });
      },
    }));

    describe('useEVSICalculations', () => {
      beforeEach(() => {
        // Reset store to initial state
        useWizardStore.getState().resetWizard();
      });

      it('returns null when mode is basic', () => {
        const { result } = renderHook(() => useEVSICalculations());
        expect(result.current.results).toBeNull();
        expect(result.current.isLoading).toBe(false);
      });

      it('returns null when inputs are incomplete', () => {
        useWizardStore.getState().setMode('advanced');
        const { result } = renderHook(() => useEVSICalculations());
        expect(result.current.results).toBeNull();
      });

      it('returns results when all inputs are complete (Normal prior)', async () => {
        const store = useWizardStore.getState();
        store.setMode('advanced');

        // Set shared inputs
        store.setSharedInput('baselineConversionRate', 0.05);
        store.setSharedInput('annualVisitors', 1000000);
        store.setSharedInput('valuePerConversion', 50);
        store.setSharedInput('thresholdScenario', 'any-positive');
        store.setSharedInput('priorIntervalLow', -8.22);
        store.setSharedInput('priorIntervalHigh', 8.22);

        // Set advanced inputs
        store.setAdvancedInput('priorShape', 'normal');
        store.setAdvancedInput('testDurationDays', 14);
        store.setAdvancedInput('dailyTraffic', 3000);

        const { result } = renderHook(() => useEVSICalculations());

        await waitFor(() => {
          expect(result.current.results).not.toBeNull();
        });

        expect(result.current.results?.evsi.evsiDollars).toBeGreaterThanOrEqual(0);
        expect(result.current.results?.netValueDollars).toBeGreaterThanOrEqual(0);
      });

      it('calculates CoD correctly when default is Ship', async () => {
        const store = useWizardStore.getState();
        store.setMode('advanced');

        // Set inputs where default decision is Ship (mu > threshold)
        store.setSharedInput('baselineConversionRate', 0.05);
        store.setSharedInput('annualVisitors', 1000000);
        store.setSharedInput('valuePerConversion', 50);
        store.setSharedInput('thresholdScenario', 'any-positive');
        store.setSharedInput('priorIntervalLow', 0);  // Positive mean
        store.setSharedInput('priorIntervalHigh', 10);

        store.setAdvancedInput('priorShape', 'normal');
        store.setAdvancedInput('testDurationDays', 14);
        store.setAdvancedInput('dailyTraffic', 3000);

        const { result } = renderHook(() => useEVSICalculations());

        await waitFor(() => {
          expect(result.current.results).not.toBeNull();
        });

        // CoD should be positive when default is Ship with positive expected value
        expect(result.current.results?.cod.codApplies).toBe(true);
        expect(result.current.results?.cod.codDollars).toBeGreaterThan(0);
      });
    });
    ```

    Note: May need to adjust Worker mocking based on actual Vite/Vitest Worker handling.
  </action>
  <verify>
    - `npm test -- useEVSICalculations` passes
    - Tests cover null returns, loading state, and complete calculations
  </verify>
  <done>
    useEVSICalculations tests pass, covering basic cases.
  </done>
</task>

</tasks>

<verification>
Run all tests:
```bash
npm test
```

Build to verify Worker bundling:
```bash
npm run build
```

Manual verification:
1. Start dev server
2. Switch to Advanced mode, fill all inputs
3. Check browser DevTools Network tab for Worker script loading
4. Verify results update without UI freeze
</verification>

<success_criteria>
- Web Worker compiles and bundles correctly
- useEVSICalculations returns null for incomplete inputs
- useEVSICalculations returns loading=true during Worker computation
- Normal prior uses fast path (no Worker)
- Non-Normal priors use Worker
- Results include EVSI, CoD, and netValueDollars
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-advanced-mode/05-05-SUMMARY.md`
</output>
