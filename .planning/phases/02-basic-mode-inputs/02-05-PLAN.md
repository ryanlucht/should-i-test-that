---
phase: 02-basic-mode-inputs
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/forms/UncertaintyPriorForm.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can enter custom interval values after clicking 'Use Default' button"
    - "Editing interval values does not require de-selecting anything"
    - "'Use Default' button fills values without creating a selected/locked state"
  artifacts:
    - path: "src/components/forms/UncertaintyPriorForm.tsx"
      provides: "Simple action button that fills values, no radio-style visual feedback"
  key_links:
    - from: "Use Default button"
      to: "Interval inputs"
      via: "setValue fills values, no persistent selection state"
      pattern: "setValue\\('intervalLow'.*setValue\\('intervalHigh'"
---

<objective>
Fix UX confusion with the default prior selection button.

**Problem:** The "Use Recommended Default" button has radio-style visual feedback (filled circle, border highlight) that suggests mutual exclusion with custom input. Users cannot override the default values because the button appears "selected" and there's no way to "de-select" it.

**Solution:** Convert from a stateful radio-style selector to a simple action button that:
1. Fills the interval fields with default values when clicked
2. Has no persistent "selected" visual state
3. Does not block subsequent editing of the interval fields

**UAT Reference:** Test 6
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-basic-mode-inputs/02-UAT.md
@src/components/forms/UncertaintyPriorForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert default prior button from radio-style to action button</name>
  <files>src/components/forms/UncertaintyPriorForm.tsx</files>
  <action>
Refactor the "Use Recommended Default" button (lines 222-260) to be a simple action button:

1. **Remove priorType from form state and visual feedback:**
   - Keep priorType in form for validation/storage, but don't use it for button styling
   - The button should look the same whether or not default values are currently in the fields

2. **Replace the radio-style button styling (lines 225-231):**
   Current (conditional styling based on priorType):
   ```typescript
   className={cn(
     'w-full rounded-xl border-2 p-4 text-left transition-all',
     'hover:border-primary/50 hover:shadow-sm',
     'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',
     priorType === 'default'
       ? 'border-primary bg-primary/5'
       : 'border-border bg-card'
   )}
   ```

   New (always same styling, no "selected" state):
   ```typescript
   className={cn(
     'w-full rounded-xl border-2 p-4 text-left transition-all',
     'hover:border-primary/50 hover:shadow-sm',
     'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',
     'border-border bg-card hover:bg-muted/50'
   )}
   ```

3. **Remove the radio indicator circle (lines 234-245):**
   Delete this entire block:
   ```typescript
   <div
     className={cn(
       'mt-0.5 h-5 w-5 rounded-full border-2 flex items-center justify-center',
       priorType === 'default'
         ? 'border-primary bg-primary'
         : 'border-muted-foreground'
     )}
   >
     {priorType === 'default' && (
       <div className="h-2 w-2 rounded-full bg-white" />
     )}
   </div>
   ```

   Replace with a simple icon (optional) or just remove the indicator entirely.

4. **Simplify handleIntervalChange (lines 172-182):**
   Remove the auto-switching logic that detects "custom" based on tolerance. The priorType can be derived at validation time based on whether values match defaults, not stored as UI state.

   Or simplify to: when user edits ANY interval field, set priorType to 'custom':
   ```typescript
   const handleIntervalChange = useCallback(() => {
     setValue('priorType', 'custom');
   }, [setValue]);
   ```

5. **Update handleUseDefault to be a pure action:**
   Keep as-is - it already correctly fills values. Just ensure it also sets priorType to 'default' for data purposes (not UI).

6. **Update button text to sound more like an action:**
   Change from "Use Recommended Default" to "Fill with defaults" or keep as-is but make it clear it's an action, not a selection.
  </action>
  <verify>
Run `npm test` to ensure tests pass.
Manual test:
1. Click "Use Recommended Default" - values fill to -8.22% and +8.22%
2. Change lower bound to -5% - value updates, no visual "lock" preventing edit
3. Change upper bound to 15% - implied mean shows 5%, asymmetry message appears
  </verify>
  <done>
Default prior button is a simple action that fills values. Users can freely edit interval fields after clicking it. No radio-style "selected" visual state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Derive priorType at validation time</name>
  <files>src/components/forms/UncertaintyPriorForm.tsx</files>
  <action>
Update the onSubmit handler to derive priorType based on actual interval values:

```typescript
const onSubmit = useCallback(
  (data: PriorSelectionFormData) => {
    // Derive priorType based on whether values match defaults
    const isDefault =
      Math.abs(data.intervalLow - DEFAULT_INTERVAL.low) < 0.01 &&
      Math.abs(data.intervalHigh - DEFAULT_INTERVAL.high) < 0.01;

    const derivedPriorType = isDefault ? 'default' : 'custom';

    setSharedInput('priorType', derivedPriorType);
    setSharedInput('priorIntervalLow', data.intervalLow);
    setSharedInput('priorIntervalHigh', data.intervalHigh);
  },
  [setSharedInput]
);
```

This ensures:
- If user clicks "Use Default" and doesn't edit: stored as 'default'
- If user edits any value away from defaults: stored as 'custom'
- No need for complex auto-detection during typing

Also update the sync useEffect (lines 184-200) to not restore priorType from store (or only use it for initial defaultValues).
  </action>
  <verify>
Run `npm test` to ensure tests pass.
Manual test:
1. Fill defaults -> advance -> values stored as 'default'
2. Edit to custom values -> advance -> values stored as 'custom'
3. Back nav preserves values correctly
  </verify>
  <done>priorType is derived from actual interval values at validation time, not tracked as separate UI state.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes
2. `npm test` passes
3. Manual UAT re-test:
   - Test 6: Can enter custom interval values (-5% to 15%) after selecting default
   - Test 7 (previously skipped): Asymmetry message appears for non-zero implied mean
</verification>

<success_criteria>
- "Use Recommended Default" button fills values without creating a "selected" visual state
- Users can freely edit interval values at any time
- priorType is derived from values, not stored as blocking UI state
- UAT Test 6 passes, Test 7 is unblocked
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-mode-inputs/02-05-SUMMARY.md`
</output>
