---
phase: 01-foundation-wizard-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - src/pages/CalculatorPage.tsx
  - src/components/wizard/SectionWrapper.tsx
  - src/components/wizard/StickyProgressIndicator.tsx
  - src/components/wizard/NavigationButtons.tsx
  - src/components/wizard/ModeToggle.tsx
  - src/hooks/useScrollSpy.ts
  - src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User sees all 4 sections on single scrollable page"
    - "Future sections appear dramatically disabled (muted, non-interactive)"
    - "Sticky indicator shows current section and completed sections (checkmarks)"
    - "Scrolling updates the active section in the indicator"
    - "Back/Next buttons navigate between sections"
    - "Completing a section enables the next section"
    - "Mode toggle in header allows switching between Basic/Advanced"
    - "Keyboard navigation works (Tab through inputs, Enter advances)"
  artifacts:
    - path: "src/pages/CalculatorPage.tsx"
      provides: "Calculator page with all sections"
      exports: ["CalculatorPage"]
    - path: "src/components/wizard/SectionWrapper.tsx"
      provides: "Section container with disabled state"
      exports: ["SectionWrapper"]
    - path: "src/components/wizard/StickyProgressIndicator.tsx"
      provides: "Sticky progress indicator"
      exports: ["StickyProgressIndicator"]
    - path: "src/components/wizard/NavigationButtons.tsx"
      provides: "Back/Next navigation"
      exports: ["NavigationButtons"]
    - path: "src/hooks/useScrollSpy.ts"
      provides: "Scroll tracking hook"
      exports: ["useScrollSpy"]
  key_links:
    - from: "src/pages/CalculatorPage.tsx"
      to: "src/stores/wizardStore.ts"
      via: "store hook"
      pattern: "useWizardStore"
    - from: "src/components/wizard/StickyProgressIndicator.tsx"
      to: "src/hooks/useScrollSpy.ts"
      via: "scroll tracking"
      pattern: "useScrollSpy"
    - from: "src/components/wizard/SectionWrapper.tsx"
      to: "fieldset disabled"
      via: "native form disabling"
      pattern: "<fieldset.*disabled"
---

<objective>
Implement the Calculator page with section wrappers, sticky progress indicator, scroll tracking, and navigation buttons.

Purpose: Create the main wizard interface where users will enter their inputs. This plan delivers the core navigation and progressive disclosure UX - sections visible but disabled until reached, with clear progress indication.

Output: Working Calculator page with 4 placeholder sections, dramatically disabled future sections, sticky indicator with scroll tracking, and Back/Next navigation.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-wizard-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-wizard-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-wizard-infrastructure/01-03-SUMMARY.md (for Zustand store types/exports)
@.planning/phases/01-foundation-wizard-infrastructure/designs/calculator-page.md (Stitch design reference)

**From CONTEXT.md (LOCKED DECISIONS):**
- Single scrollable page with all sections visible
- Future sections dramatically disabled (40% opacity, grayscale, pointer-events-none)
- Sticky mini-indicator with numbered dots, checkmarks for completed
- Generic "Back" / "Next" button labels
- Validation only on Next click
- Tab through inputs, Enter advances to next section

**From RESEARCH.md - Key Patterns:**
- `<fieldset disabled>` for native form control disabling
- IntersectionObserver with rootMargin for scroll tracking
- scroll-mt-{N} to account for sticky header height
- Cleanup IntersectionObserver in useEffect return
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SectionWrapper and NavigationButtons components</name>
  <files>
    src/components/wizard/SectionWrapper.tsx
    src/components/wizard/NavigationButtons.tsx
  </files>
  <action>
    1. Create src/components/wizard/SectionWrapper.tsx:
       ```tsx
       import { ReactNode, KeyboardEvent } from 'react';
       import { cn } from '@/lib/utils';
       import { Check } from 'lucide-react';

       interface SectionWrapperProps {
         id: string;
         title: string;
         sectionNumber: number;
         isEnabled: boolean;
         isCompleted: boolean;
         isCurrent: boolean;
         children: ReactNode;
       }

       /**
        * SectionWrapper provides the container for each wizard section.
        *
        * Key behaviors:
        * - Uses <fieldset disabled> to natively disable all form controls when not enabled
        * - Dramatically muted styling (opacity, grayscale) for disabled sections
        * - scroll-mt-24 accounts for sticky header + indicator height (~96px)
        * - aria-labelledby for accessibility
        */
       export function SectionWrapper({
         id,
         title,
         sectionNumber,
         isEnabled,
         isCompleted,
         isCurrent,
         children,
       }: SectionWrapperProps) {
         return (
           <section
             id={id}
             className={cn(
               // Scroll offset for sticky header (header ~64px + indicator ~32px = ~96px, use 24 = 6rem)
               'scroll-mt-24',
               'rounded-lg border transition-all duration-300',
               isEnabled
                 ? 'border-border bg-card shadow-sm'
                 : 'border-muted/50 bg-muted/20',
               isCurrent && isEnabled && 'ring-2 ring-primary/20'
             )}
             aria-labelledby={`${id}-heading`}
           >
             {/* Section Header */}
             <div
               className={cn(
                 'px-6 py-4 border-b',
                 isEnabled ? 'border-border' : 'border-muted/30'
               )}
             >
               <h2
                 id={`${id}-heading`}
                 className={cn(
                   'text-lg font-semibold flex items-center gap-2',
                   !isEnabled && 'text-muted-foreground/60'
                 )}
               >
                 <span
                   className={cn(
                     'flex h-7 w-7 items-center justify-center rounded-full text-sm font-medium',
                     isCompleted
                       ? 'bg-green-600 text-white'
                       : isEnabled
                       ? 'bg-primary text-primary-foreground'
                       : 'bg-muted text-muted-foreground'
                   )}
                 >
                   {isCompleted ? (
                     <Check className="h-4 w-4" aria-label="Completed" />
                   ) : (
                     sectionNumber
                   )}
                 </span>
                 <span>{title}</span>
               </h2>
             </div>

             {/* Section Content - fieldset disabled propagates to ALL descendant form controls */}
             <fieldset
               disabled={!isEnabled}
               className={cn(
                 'p-6',
                 !isEnabled && 'opacity-40 grayscale pointer-events-none select-none'
               )}
               aria-disabled={!isEnabled}
             >
               {children}
             </fieldset>

             {/* Locked message for disabled sections */}
             {!isEnabled && (
               <div className="px-6 pb-4">
                 <p className="text-sm text-muted-foreground/60 italic">
                   Complete the previous section to unlock this step.
                 </p>
               </div>
             )}
           </section>
         );
       }
       ```

    2. Create src/components/wizard/NavigationButtons.tsx:
       ```tsx
       import { Button } from '@/components/ui/button';
       import { ArrowLeft, ArrowRight } from 'lucide-react';

       interface NavigationButtonsProps {
         onBack: () => void;
         onNext: () => void;
         canGoBack: boolean;
         canGoNext: boolean;
         isFirstSection: boolean;
         isLastSection: boolean;
         isValidating?: boolean;
       }

       /**
        * NavigationButtons provides Back/Next controls for each section.
        *
        * Per CONTEXT.md:
        * - Generic "Back" / "Next" labels on all sections
        * - "See Results" on last section
        * - Validation happens on Next click (not here - parent handles)
        */
       export function NavigationButtons({
         onBack,
         onNext,
         canGoBack,
         canGoNext,
         isFirstSection,
         isLastSection,
         isValidating = false,
       }: NavigationButtonsProps) {
         return (
           <div className="flex justify-between items-center pt-6 mt-6 border-t">
             <Button
               type="button"
               variant="outline"
               onClick={onBack}
               disabled={!canGoBack || isFirstSection}
               className={cn(
                 isFirstSection && 'invisible' // Hide but maintain layout
               )}
             >
               <ArrowLeft className="h-4 w-4 mr-2" />
               Back
             </Button>

             <Button
               type="button"
               onClick={onNext}
               disabled={!canGoNext || isValidating}
             >
               {isLastSection ? 'See Results' : 'Next'}
               {!isLastSection && <ArrowRight className="h-4 w-4 ml-2" />}
             </Button>
           </div>
         );
       }

       // Need to import cn
       import { cn } from '@/lib/utils';
       ```

    3. Ensure directory exists:
       ```bash
       mkdir -p src/components/wizard
       ```
  </action>
  <verify>
    Run `npm run build` - should compile without TypeScript errors.
    Components should export correctly when imported.
  </verify>
  <done>
    SectionWrapper with dramatic disabled state (fieldset + opacity + grayscale) and NavigationButtons with Back/Next created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement sticky progress indicator with scroll spy</name>
  <files>
    src/hooks/useScrollSpy.ts
    src/components/wizard/StickyProgressIndicator.tsx
    src/components/wizard/ModeToggle.tsx
  </files>
  <action>
    1. Create src/hooks/useScrollSpy.ts:
       ```typescript
       import { useEffect, useState, useCallback, useRef } from 'react';

       /**
        * useScrollSpy tracks which section is currently in the viewport.
        *
        * Uses IntersectionObserver for performance (not scroll events).
        * rootMargin is set to trigger when section enters top 40% of viewport.
        *
        * @param sectionIds - Array of section DOM IDs to observe
        * @returns Currently active section ID
        */
       export function useScrollSpy(sectionIds: string[]): string {
         const [activeSection, setActiveSection] = useState<string>(sectionIds[0] || '');
         const observerRef = useRef<IntersectionObserver | null>(null);

         useEffect(() => {
           // Cleanup previous observer
           if (observerRef.current) {
             observerRef.current.disconnect();
           }

           // Track intersection ratios for each section
           const intersectionMap = new Map<string, number>();

           observerRef.current = new IntersectionObserver(
             (entries) => {
               entries.forEach((entry) => {
                 intersectionMap.set(entry.target.id, entry.intersectionRatio);
               });

               // Find the section with highest intersection ratio in view
               let maxRatio = 0;
               let activeId = sectionIds[0];

               intersectionMap.forEach((ratio, id) => {
                 // Prefer sections that are more visible
                 if (ratio > maxRatio) {
                   maxRatio = ratio;
                   activeId = id;
                 }
               });

               // Only update if we have meaningful intersection
               if (maxRatio > 0) {
                 setActiveSection(activeId);
               }
             },
             {
               // Trigger when section is in top portion of viewport
               // -10% from top, -50% from bottom = middle 40% triggers
               rootMargin: '-10% 0px -50% 0px',
               threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5],
             }
           );

           // Observe all sections
           sectionIds.forEach((id) => {
             const element = document.getElementById(id);
             if (element) {
               observerRef.current?.observe(element);
             }
           });

           // Cleanup on unmount
           return () => {
             observerRef.current?.disconnect();
           };
         }, [sectionIds]);

         return activeSection;
       }
       ```

    2. Create src/components/wizard/StickyProgressIndicator.tsx:
       ```tsx
       import { cn } from '@/lib/utils';
       import { Check } from 'lucide-react';

       interface Step {
         id: string;
         label: string;
         shortLabel: string; // For mobile
       }

       interface StickyProgressIndicatorProps {
         steps: Step[];
         activeStepId: string;
         completedStepIds: string[];
         onStepClick: (stepId: string) => void;
         canAccessStep: (stepId: string) => boolean;
       }

       /**
        * StickyProgressIndicator shows numbered dots for each section.
        *
        * Per CONTEXT.md:
        * - Sticky at top (below header)
        * - Small numbered dots/circles
        * - Current section highlighted
        * - Completed sections show checkmark (green)
        * - Mobile: keep horizontal with abbreviated labels
        */
       export function StickyProgressIndicator({
         steps,
         activeStepId,
         completedStepIds,
         onStepClick,
         canAccessStep,
       }: StickyProgressIndicatorProps) {
         return (
           <nav
             aria-label="Calculator progress"
             className="sticky top-16 z-40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/80 border-b"
           >
             <div className="container max-w-4xl mx-auto px-4">
               <ol className="flex justify-center items-center gap-1 sm:gap-2 py-3">
                 {steps.map((step, index) => {
                   const isActive = step.id === activeStepId;
                   const isCompleted = completedStepIds.includes(step.id);
                   const canAccess = canAccessStep(step.id);
                   const stepNumber = index + 1;

                   return (
                     <li key={step.id} className="flex items-center">
                       {/* Connector line (not before first item) */}
                       {index > 0 && (
                         <div
                           className={cn(
                             'w-4 sm:w-8 h-0.5 mx-1',
                             completedStepIds.includes(steps[index - 1].id)
                               ? 'bg-green-600'
                               : 'bg-muted'
                           )}
                         />
                       )}

                       <button
                         onClick={() => canAccess && onStepClick(step.id)}
                         disabled={!canAccess}
                         className={cn(
                           'flex items-center gap-1.5 px-2 py-1.5 rounded-full text-xs sm:text-sm transition-all',
                           'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2',
                           isActive && 'bg-primary text-primary-foreground shadow-sm',
                           isCompleted && !isActive && 'text-green-700',
                           !isActive && !isCompleted && canAccess && 'text-muted-foreground hover:text-foreground',
                           !canAccess && 'text-muted-foreground/50 cursor-not-allowed'
                         )}
                         aria-current={isActive ? 'step' : undefined}
                         aria-disabled={!canAccess}
                       >
                         {/* Step number or checkmark */}
                         <span
                           className={cn(
                             'flex h-6 w-6 items-center justify-center rounded-full text-xs font-medium transition-colors',
                             isCompleted
                               ? 'bg-green-600 text-white'
                               : isActive
                               ? 'bg-primary-foreground/20 text-primary-foreground'
                               : canAccess
                               ? 'bg-muted text-muted-foreground'
                               : 'bg-muted/50 text-muted-foreground/50'
                           )}
                         >
                           {isCompleted ? (
                             <Check className="h-3.5 w-3.5" aria-hidden="true" />
                           ) : (
                             stepNumber
                           )}
                         </span>

                         {/* Label - full on sm+, short on mobile */}
                         <span className="hidden sm:inline">{step.label}</span>
                         <span className="sm:hidden">{step.shortLabel}</span>
                       </button>
                     </li>
                   );
                 })}
               </ol>
             </div>
           </nav>
         );
       }
       ```

    3. Create src/components/wizard/ModeToggle.tsx:
       ```tsx
       import { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group';
       import { useWizardStore } from '@/stores/wizardStore';
       import type { Mode } from '@/types/wizard';

       /**
        * ModeToggle provides segmented control to switch between Basic and Advanced.
        *
        * Per CONTEXT.md:
        * - Always visible in calculator header
        * - Preserve shared inputs when switching (store handles this)
        */
       export function ModeToggle() {
         const { mode, setMode } = useWizardStore();

         return (
           <ToggleGroup
             type="single"
             value={mode}
             onValueChange={(value) => {
               if (value) setMode(value as Mode);
             }}
             className="border rounded-lg bg-muted/30 p-1"
           >
             <ToggleGroupItem
               value="basic"
               aria-label="Basic Mode"
               className="px-3 py-1.5 text-sm data-[state=on]:bg-background data-[state=on]:shadow-sm rounded-md"
             >
               Basic
             </ToggleGroupItem>
             <ToggleGroupItem
               value="advanced"
               aria-label="Advanced Mode"
               className="px-3 py-1.5 text-sm data-[state=on]:bg-background data-[state=on]:shadow-sm rounded-md"
             >
               Advanced
             </ToggleGroupItem>
           </ToggleGroup>
         );
       }
       ```

    4. Ensure hooks directory exists:
       ```bash
       mkdir -p src/hooks
       ```
  </action>
  <verify>
    Run `npm run build` - should compile without errors.
    Components export correctly.
  </verify>
  <done>
    useScrollSpy hook with IntersectionObserver, StickyProgressIndicator with dots/checkmarks, and ModeToggle segmented control created.
  </done>
</task>

<task type="auto">
  <name>Task 3: Assemble CalculatorPage with all sections and navigation</name>
  <files>
    src/pages/CalculatorPage.tsx
    src/App.tsx
  </files>
  <action>
    1. Create src/pages/CalculatorPage.tsx:
       ```tsx
       import { useCallback, useMemo } from 'react';
       import { useWizardStore, SECTION_ORDER } from '@/stores/wizardStore';
       import { useScrollSpy } from '@/hooks/useScrollSpy';
       import { SectionWrapper } from '@/components/wizard/SectionWrapper';
       import { StickyProgressIndicator } from '@/components/wizard/StickyProgressIndicator';
       import { NavigationButtons } from '@/components/wizard/NavigationButtons';
       import { ModeToggle } from '@/components/wizard/ModeToggle';
       import type { SectionId } from '@/types/wizard';

       /**
        * Section configuration
        * Maps section IDs to display metadata
        */
       const SECTIONS = [
         { id: 'baseline' as SectionId, title: 'Baseline Metrics', label: 'Baseline', shortLabel: 'Base' },
         { id: 'uncertainty' as SectionId, title: 'Uncertainty', label: 'Uncertainty', shortLabel: 'Prior' },
         { id: 'threshold' as SectionId, title: 'Shipping Threshold', label: 'Threshold', shortLabel: 'Goal' },
         { id: 'results' as SectionId, title: 'Results', label: 'Results', shortLabel: 'Result' },
       ];

       interface CalculatorPageProps {
         onBackToWelcome: () => void;
       }

       export function CalculatorPage({ onBackToWelcome }: CalculatorPageProps) {
         const {
           mode,
           navigation,
           setCurrentSection,
           markSectionComplete,
           canAccessSection,
         } = useWizardStore();

         const { currentSection, completedSections } = navigation;

         // Scroll spy to track which section is in view
         const activeSectionId = useScrollSpy(SECTIONS.map((s) => s.id));

         // Steps for progress indicator
         const steps = useMemo(
           () =>
             SECTIONS.map((s) => ({
               id: s.id,
               label: s.label,
               shortLabel: s.shortLabel,
             })),
           []
         );

         // Navigate to a section (scroll into view)
         const scrollToSection = useCallback((sectionId: string) => {
           const element = document.getElementById(sectionId);
           if (element) {
             element.scrollIntoView({ behavior: 'smooth', block: 'start' });
             setCurrentSection(sectionId as SectionId);
           }
         }, [setCurrentSection]);

         // Handle Next button - validate and advance
         const handleNext = useCallback(
           (currentId: SectionId) => {
             // TODO: Add validation logic here in Phase 2
             // For now, just mark complete and advance

             markSectionComplete(currentId);

             const currentIndex = SECTION_ORDER.indexOf(currentId);
             if (currentIndex < SECTION_ORDER.length - 1) {
               const nextSection = SECTION_ORDER[currentIndex + 1];
               scrollToSection(nextSection);
             }
           },
           [markSectionComplete, scrollToSection]
         );

         // Handle Back button
         const handleBack = useCallback(
           (currentId: SectionId) => {
             const currentIndex = SECTION_ORDER.indexOf(currentId);
             if (currentIndex > 0) {
               const prevSection = SECTION_ORDER[currentIndex - 1];
               scrollToSection(prevSection);
             }
           },
           [scrollToSection]
         );

         // Handle Enter key to advance (per CONTEXT.md)
         const handleKeyDown = useCallback(
           (event: React.KeyboardEvent, sectionId: SectionId) => {
             if (event.key === 'Enter' && !event.shiftKey) {
               // Only advance if not in a textarea
               const target = event.target as HTMLElement;
               if (target.tagName !== 'TEXTAREA') {
                 event.preventDefault();
                 handleNext(sectionId);
               }
             }
           },
           [handleNext]
         );

         return (
           <div className="min-h-screen bg-background">
             {/* Header with mode toggle */}
             <header className="sticky top-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/80 border-b">
               <div className="container max-w-4xl mx-auto px-4 py-3 flex items-center justify-between">
                 <button
                   onClick={onBackToWelcome}
                   className="text-sm text-muted-foreground hover:text-foreground transition-colors"
                 >
                   &larr; Start Over
                 </button>
                 <h1 className="text-lg font-semibold">Should I Test That?</h1>
                 <ModeToggle />
               </div>
             </header>

             {/* Progress Indicator */}
             <StickyProgressIndicator
               steps={steps}
               activeStepId={activeSectionId}
               completedStepIds={completedSections}
               onStepClick={scrollToSection}
               canAccessStep={(id) => canAccessSection(id as SectionId)}
             />

             {/* Main Content */}
             <main className="container max-w-4xl mx-auto px-4 py-8 space-y-6">
               {SECTIONS.map((section, index) => {
                 const isEnabled = canAccessSection(section.id);
                 const isCompleted = completedSections.includes(section.id);
                 const isCurrent = activeSectionId === section.id;
                 const isFirstSection = index === 0;
                 const isLastSection = index === SECTIONS.length - 1;

                 return (
                   <div
                     key={section.id}
                     onKeyDown={(e) => isEnabled && handleKeyDown(e, section.id)}
                   >
                     <SectionWrapper
                       id={section.id}
                       title={section.title}
                       sectionNumber={index + 1}
                       isEnabled={isEnabled}
                       isCompleted={isCompleted}
                       isCurrent={isCurrent}
                     >
                       {/* Placeholder content - real forms come in Phase 2 */}
                       <div className="space-y-4">
                         <p className="text-muted-foreground">
                           {section.id === 'baseline' && (
                             <>
                               Enter your baseline conversion rate, annual traffic, and value per conversion.
                               <br />
                               <span className="text-sm italic">(Form inputs coming in Phase 2)</span>
                             </>
                           )}
                           {section.id === 'uncertainty' && (
                             <>
                               Define your uncertainty about the potential lift from this change.
                               <br />
                               <span className="text-sm italic">(Prior selection coming in Phase 2)</span>
                             </>
                           )}
                           {section.id === 'threshold' && (
                             <>
                               Set your shipping threshold - the minimum impact to justify shipping.
                               <br />
                               <span className="text-sm italic">(Threshold inputs coming in Phase 2)</span>
                             </>
                           )}
                           {section.id === 'results' && (
                             <>
                               See whether this A/B test is worth running based on your inputs.
                               <br />
                               <span className="text-sm italic">(Results display coming in Phase 4)</span>
                             </>
                           )}
                         </p>

                         {/* Placeholder inputs for demo */}
                         {section.id !== 'results' && isEnabled && (
                           <div className="bg-muted/30 rounded-lg p-4 border border-dashed">
                             <p className="text-sm text-muted-foreground mb-2">Demo input (Tab + Enter to advance):</p>
                             <input
                               type="text"
                               placeholder={`Enter ${section.title.toLowerCase()} value...`}
                               className="w-full px-3 py-2 rounded-md border bg-background focus:outline-none focus:ring-2 focus:ring-primary"
                             />
                           </div>
                         )}

                         {/* Navigation Buttons */}
                         {isEnabled && (
                           <NavigationButtons
                             onBack={() => handleBack(section.id)}
                             onNext={() => handleNext(section.id)}
                             canGoBack={!isFirstSection}
                             canGoNext={true}
                             isFirstSection={isFirstSection}
                             isLastSection={isLastSection}
                           />
                         )}
                       </div>
                     </SectionWrapper>
                   </div>
                 );
               })}

               {/* Footer spacing */}
               <div className="h-32" />
             </main>
           </div>
         );
       }
       ```

    2. Update src/App.tsx to use CalculatorPage:
       ```tsx
       import { useState } from 'react';
       import { WelcomePage } from '@/pages/WelcomePage';
       import { CalculatorPage } from '@/pages/CalculatorPage';

       type Page = 'welcome' | 'calculator';

       function App() {
         const [currentPage, setCurrentPage] = useState<Page>('welcome');

         if (currentPage === 'welcome') {
           return <WelcomePage onProceed={() => setCurrentPage('calculator')} />;
         }

         return <CalculatorPage onBackToWelcome={() => setCurrentPage('welcome')} />;
       }

       export default App;
       ```

    3. Install lucide-react if not present (for icons):
       ```bash
       npm install lucide-react
       ```
  </action>
  <verify>
    Run `npm run dev` and test full flow:
    1. Welcome page -> select mode -> Get Started
    2. Calculator page shows with 4 sections
    3. Only first section is enabled (others are grayed out)
    4. Click Next on first section -> enables second section
    5. Scroll down -> sticky indicator updates to show active section
    6. Click on step 1 in indicator -> scrolls back to section 1
    7. Completed sections show green checkmarks
    8. Tab to input, press Enter -> advances to next section
    9. Mode toggle switches between Basic/Advanced
    10. "Start Over" returns to Welcome page

    Run `npm run build` - should compile without errors.
  </verify>
  <done>
    CalculatorPage assembled with all 4 sections, dramatic disabled states, sticky indicator with scroll tracking, and Back/Next navigation working.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete wizard navigation infrastructure:
    1. Welcome page with mode selection (Basic/Advanced cards)
    2. Calculator page with 4 sections on single scrollable page
    3. Dramatic disabled state for future sections (40% opacity + grayscale)
    4. Sticky progress indicator with numbered dots and checkmarks
    5. Scroll spy that updates indicator as user scrolls
    6. Back/Next navigation buttons per section
    7. Enter key advances to next section
    8. Mode toggle in header to switch modes anytime
    9. Session persistence for mode and inputs
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Open http://localhost:5173 in browser

    **Welcome Page:**
    - [ ] Two mode cards visible (Basic Mode, Advanced Mode)
    - [ ] Selecting a card shows clear visual highlight (ring/border)
    - [ ] "Get Started" button navigates to Calculator

    **Calculator Page - Layout:**
    - [ ] All 4 sections visible on single scrollable page
    - [ ] Future sections (2, 3, 4) appear dramatically disabled (muted, grayed)
    - [ ] First section (Baseline) is active and enabled

    **Calculator Page - Navigation:**
    - [ ] Clicking "Next" on section 1 enables section 2
    - [ ] Completing a section shows green checkmark in indicator
    - [ ] "Back" button navigates to previous section
    - [ ] Scroll down - indicator updates to show current section
    - [ ] Click indicator dot - scrolls to that section
    - [ ] Tab to input field, press Enter - advances to next section

    **Calculator Page - Mode Toggle:**
    - [ ] Mode toggle shows [Basic] [Advanced] buttons in header
    - [ ] Clicking toggle switches mode
    - [ ] Mode persists on page refresh

    **Overall Feel:**
    - [ ] Does the disabled state feel "dramatic" enough?
    - [ ] Is the sticky indicator minimal and unobtrusive?
    - [ ] Does scroll tracking feel responsive?
    - [ ] Any visual tweaks needed before moving to Phase 2?
  </how-to-verify>
  <resume-signal>
    Type "approved" if the wizard navigation meets your expectations.
    Or describe specific issues (e.g., "disabled sections not muted enough", "indicator too large", "scroll tracking laggy").
  </resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:
1. Full wizard flow works: Welcome -> Calculator -> navigate sections -> complete
2. Disabled sections are visually dramatic and non-interactive
3. Sticky indicator tracks scroll position accurately
4. Keyboard navigation works (Tab + Enter)
5. Mode toggle switches between Basic/Advanced
6. Session persistence works for mode and inputs
7. User has approved the navigation UX

Test commands:
```bash
npm run build
npm run dev
```
</verification>

<success_criteria>
- Calculator page shows all 4 sections on single scrollable page
- Future sections are dramatically disabled (fieldset + opacity + grayscale)
- Sticky indicator updates on scroll and shows completed checkmarks
- Back/Next navigation works correctly
- Enter key advances sections
- Mode toggle allows switching anytime
- User approved the wizard navigation UX
</success_criteria>

<output>
After completion (including checkpoint approval), create `.planning/phases/01-foundation-wizard-infrastructure/01-04-SUMMARY.md`
</output>
