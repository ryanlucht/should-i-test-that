---
phase: 01-foundation-wizard-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/stores/wizardStore.ts
  - src/types/wizard.ts
  - src/pages/WelcomePage.tsx
  - src/components/welcome/ModeCard.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can select Basic or Advanced mode on Welcome screen"
    - "Selected mode is persisted to session storage"
    - "Clicking 'Get Started' navigates to Calculator page"
    - "Mode selection cards show clear selected/unselected states"
    - "Shared inputs persist across mode switches"
    - "Advanced-only inputs are cleared when switching to Basic mode"
  artifacts:
    - path: "src/stores/wizardStore.ts"
      provides: "Zustand store for wizard state"
      exports: ["useWizardStore"]
    - path: "src/types/wizard.ts"
      provides: "TypeScript types for wizard"
      exports: ["Mode", "WizardState", "InputsState"]
    - path: "src/pages/WelcomePage.tsx"
      provides: "Welcome page component"
      exports: ["WelcomePage"]
    - path: "src/components/welcome/ModeCard.tsx"
      provides: "Mode selection card component"
      exports: ["ModeSelection"]
  key_links:
    - from: "src/pages/WelcomePage.tsx"
      to: "src/stores/wizardStore.ts"
      via: "store hook"
      pattern: "useWizardStore"
    - from: "src/stores/wizardStore.ts"
      to: "sessionStorage"
      via: "zustand persist middleware"
      pattern: "persist.*sessionStorage"
---

<objective>
Implement wizard state management with Zustand and build the Welcome page with mode selection.

Purpose: Establish the state foundation for the wizard (mode, inputs, navigation) and create the entry point where users choose Basic or Advanced mode.

Output: Working Zustand store with session persistence, and Welcome page with selectable mode cards that navigate to Calculator page.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-wizard-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-wizard-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-wizard-infrastructure/01-01-SUMMARY.md (for shadcn components available)
@.planning/phases/01-foundation-wizard-infrastructure/designs/welcome-screen.md (Stitch design reference)

**From CONTEXT.md:**
- Welcome screen: Two side-by-side cards for mode selection
- Mode switch behavior: Preserve shared inputs when switching modes
- Advanced-only fields should be cleared when switching to Basic mode
- Skip leave warning (no unsaved data protection needed)

**From RESEARCH.md - Zustand Pattern:**
- Use persist middleware with sessionStorage
- Store both inputs and mode, but only persist inputs + mode (not navigation state)
- Use arrays instead of Sets for serialization compatibility
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Zustand wizard store with types</name>
  <files>
    src/types/wizard.ts
    src/stores/wizardStore.ts
  </files>
  <action>
    1. Create src/types/wizard.ts:
       ```typescript
       /**
        * Wizard type definitions for "Should I Test That?" calculator
        * These types support both Basic and Advanced modes
        */

       export type Mode = 'basic' | 'advanced';

       /**
        * Section IDs for the calculator wizard
        * Used for navigation tracking and scroll spy
        */
       export type SectionId = 'baseline' | 'uncertainty' | 'threshold' | 'results';

       /**
        * Inputs shared between Basic and Advanced modes
        * These persist when user switches modes
        */
       export interface SharedInputs {
         // Baseline conversion rate as decimal (0.032 = 3.2%)
         baselineConversionRate: number | null;
         // Annual visitors/sessions/leads
         annualVisitors: number | null;
         // User-customized label for visitors ("visitors", "sessions", etc.)
         visitorLabel: string;
         // Dollar value per conversion
         valuePerConversion: number | null;
         // Prior: using default or custom
         useDefaultPrior: boolean;
         // Custom prior 90% interval (if not using default)
         priorLow: number | null;  // as decimal (e.g., -0.05)
         priorHigh: number | null; // as decimal (e.g., 0.10)
         // Threshold scenario: 'any-positive' | 'minimum-lift' | 'accept-loss'
         thresholdScenario: 'any-positive' | 'minimum-lift' | 'accept-loss' | null;
         // Threshold value (interpretation depends on scenario)
         thresholdValue: number | null;
         // Threshold unit: 'dollars' | 'lift'
         thresholdUnit: 'dollars' | 'lift' | null;
       }

       /**
        * Advanced mode only inputs
        * These are cleared when switching to Basic mode
        */
       export interface AdvancedInputs {
         // Prior shape for Advanced mode
         priorShape: 'normal' | 'student-t' | 'uniform';
         studentTDf: number | null; // degrees of freedom for Student-t
         // Experiment design
         trafficSplit: number; // variant fraction, e.g., 0.5 for 50/50
         testDurationDays: number | null;
         dailyTraffic: number | null;
         eligibilityFraction: number; // default 1.0 (100%)
         decisionLatencyDays: number; // default 0
         // Cost inputs
         hardCostDollars: number | null;
         laborHours: number | null;
         laborHourlyRate: number | null;
       }

       export interface InputsState extends SharedInputs {
         advanced: AdvancedInputs;
       }

       /**
        * Wizard navigation and UI state
        * NOT persisted - resets on page load
        */
       export interface NavigationState {
         currentSection: SectionId;
         completedSections: SectionId[];
       }

       /**
        * Complete wizard state
        */
       export interface WizardState {
         mode: Mode;
         inputs: InputsState;
         navigation: NavigationState;
       }

       /**
        * Wizard store actions
        */
       export interface WizardActions {
         setMode: (mode: Mode) => void;
         setInput: <K extends keyof SharedInputs>(key: K, value: SharedInputs[K]) => void;
         setAdvancedInput: <K extends keyof AdvancedInputs>(key: K, value: AdvancedInputs[K]) => void;
         setCurrentSection: (section: SectionId) => void;
         markSectionComplete: (section: SectionId) => void;
         canAccessSection: (section: SectionId) => boolean;
         resetWizard: () => void;
       }
       ```

    2. Create src/stores/wizardStore.ts:
       ```typescript
       import { create } from 'zustand';
       import { persist, createJSONStorage } from 'zustand/middleware';
       import type {
         Mode,
         SectionId,
         InputsState,
         NavigationState,
         WizardState,
         WizardActions,
         SharedInputs,
         AdvancedInputs,
       } from '@/types/wizard';

       /**
        * Section order for navigation logic
        * Used to determine if user can access a section
        */
       const SECTION_ORDER: SectionId[] = ['baseline', 'uncertainty', 'threshold', 'results'];

       /**
        * Initial state for shared inputs
        */
       const initialSharedInputs: SharedInputs = {
         baselineConversionRate: null,
         annualVisitors: null,
         visitorLabel: 'visitors',
         valuePerConversion: null,
         useDefaultPrior: true,
         priorLow: null,
         priorHigh: null,
         thresholdScenario: null,
         thresholdValue: null,
         thresholdUnit: null,
       };

       /**
        * Initial state for advanced-only inputs
        * IMPORTANT: These values are reset when switching from Advanced to Basic mode
        */
       const initialAdvancedInputs: AdvancedInputs = {
         priorShape: 'normal',
         studentTDf: null,
         trafficSplit: 0.5,
         testDurationDays: null,
         dailyTraffic: null,
         eligibilityFraction: 1.0,
         decisionLatencyDays: 0,
         hardCostDollars: null,
         laborHours: null,
         laborHourlyRate: null,
       };

       const initialInputs: InputsState = {
         ...initialSharedInputs,
         advanced: initialAdvancedInputs,
       };

       const initialNavigation: NavigationState = {
         currentSection: 'baseline',
         completedSections: [],
       };

       /**
        * Wizard store with session persistence
        *
        * Persistence strategy:
        * - inputs and mode are persisted (survive refresh within session)
        * - navigation state is NOT persisted (user starts at beginning)
        */
       export const useWizardStore = create<WizardState & WizardActions>()(
         persist(
           (set, get) => ({
             mode: 'basic',
             inputs: initialInputs,
             navigation: initialNavigation,

             setMode: (mode) => {
               /**
                * Mode switching behavior:
                * - Shared inputs are ALWAYS preserved (CR, traffic, value, etc.)
                * - When switching TO Basic mode: clear advanced-only inputs
                * - When switching TO Advanced mode: keep advanced inputs as-is (may be empty or populated)
                *
                * This ensures users don't accidentally carry over Advanced settings
                * to Basic mode calculations.
                */
               set((state) => {
                 if (mode === 'basic') {
                   // Switching to Basic: clear advanced-only fields
                   return {
                     mode,
                     inputs: {
                       ...state.inputs,
                       advanced: initialAdvancedInputs,
                     },
                   };
                 }
                 // Switching to Advanced: preserve everything
                 return { mode };
               });
             },

             setInput: (key, value) => {
               set((state) => ({
                 inputs: { ...state.inputs, [key]: value },
               }));
             },

             setAdvancedInput: (key, value) => {
               set((state) => ({
                 inputs: {
                   ...state.inputs,
                   advanced: { ...state.inputs.advanced, [key]: value },
                 },
               }));
             },

             setCurrentSection: (section) => {
               set((state) => ({
                 navigation: { ...state.navigation, currentSection: section },
               }));
             },

             markSectionComplete: (section) => {
               set((state) => {
                 const completed = state.navigation.completedSections;
                 if (completed.includes(section)) return state;
                 return {
                   navigation: {
                     ...state.navigation,
                     completedSections: [...completed, section],
                   },
                 };
               });
             },

             canAccessSection: (section) => {
               const { completedSections } = get().navigation;
               const sectionIndex = SECTION_ORDER.indexOf(section);
               if (sectionIndex === 0) return true; // First section always accessible

               // Can access if all previous sections are complete
               for (let i = 0; i < sectionIndex; i++) {
                 if (!completedSections.includes(SECTION_ORDER[i])) {
                   return false;
                 }
               }
               return true;
             },

             resetWizard: () => {
               set({
                 inputs: initialInputs,
                 navigation: initialNavigation,
               });
             },
           }),
           {
             name: 'should-i-test-that-wizard',
             storage: createJSONStorage(() => sessionStorage),
             // Only persist inputs and mode, not navigation
             partialize: (state) => ({
               mode: state.mode,
               inputs: state.inputs,
             }),
           }
         )
       );

       // Export section order for external use
       export { SECTION_ORDER };
       ```
  </action>
  <verify>
    Create a quick test in src/App.tsx:
    ```tsx
    import { useWizardStore } from '@/stores/wizardStore';

    function App() {
      const { mode, setMode, inputs, setAdvancedInput } = useWizardStore();
      return (
        <div>
          <p>Mode: {mode}</p>
          <p>Traffic Split: {inputs.advanced.trafficSplit}</p>
          <button onClick={() => setAdvancedInput('trafficSplit', 0.7)}>Set Split to 70%</button>
          <button onClick={() => setMode('basic')}>Switch to Basic</button>
          <button onClick={() => setMode('advanced')}>Switch to Advanced</button>
        </div>
      );
    }
    ```
    - Click "Set Split to 70%" - traffic split should show 0.7
    - Click "Switch to Basic" - traffic split should reset to 0.5 (initial value)
    - Click "Switch to Advanced" - traffic split stays at 0.5 (doesn't magically restore)
    - Refresh page, mode should persist (sessionStorage)
    - Close tab and reopen, mode should reset (sessionStorage clears)

    Run `npm run build` - should compile without TypeScript errors.
  </verify>
  <done>
    Zustand store created with typed state for mode, inputs (shared + advanced), and navigation. Session persistence works for inputs and mode only. Advanced inputs are correctly cleared when switching to Basic mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Welcome page with mode selection cards</name>
  <files>
    src/pages/WelcomePage.tsx
    src/components/welcome/ModeCard.tsx
    src/App.tsx
  </files>
  <action>
    1. Create src/components/welcome/ModeCard.tsx:
       ```tsx
       import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
       import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
       import { Label } from '@/components/ui/label';
       import { cn } from '@/lib/utils';
       import type { Mode } from '@/types/wizard';

       interface ModeOption {
         id: Mode;
         title: string;
         description: string;
         features: string[];
       }

       const modeOptions: ModeOption[] = [
         {
           id: 'basic',
           title: 'Basic Mode',
           description: 'Quick estimate, fewer inputs',
           features: [
             'EVPI calculation (optimistic ceiling)',
             '3 business inputs',
             'Guided prior selection',
             'Simple threshold setup',
           ],
         },
         {
           id: 'advanced',
           title: 'Advanced Mode',
           description: 'Precise value, more inputs',
           features: [
             'EVSI calculation (realistic)',
             'Multiple prior shapes',
             'Test design inputs',
             'Cost of Delay analysis',
           ],
         },
       ];

       interface ModeSelectionProps {
         selectedMode: Mode;
         onModeSelect: (mode: Mode) => void;
       }

       export function ModeSelection({ selectedMode, onModeSelect }: ModeSelectionProps) {
         return (
           <RadioGroup
             value={selectedMode}
             onValueChange={(value) => onModeSelect(value as Mode)}
             className="grid grid-cols-1 md:grid-cols-2 gap-6"
           >
             {modeOptions.map((option) => (
               <Label
                 key={option.id}
                 htmlFor={option.id}
                 className="cursor-pointer"
               >
                 <Card
                   className={cn(
                     'h-full transition-all duration-200',
                     'hover:border-primary/50 hover:shadow-md',
                     selectedMode === option.id
                       ? 'border-primary ring-2 ring-primary ring-offset-2 shadow-md'
                       : 'border-border'
                   )}
                 >
                   <CardHeader className="pb-3">
                     <div className="flex items-start gap-3">
                       <RadioGroupItem
                         value={option.id}
                         id={option.id}
                         className="mt-1"
                       />
                       <div>
                         <CardTitle className="text-lg">{option.title}</CardTitle>
                         <CardDescription className="mt-1">
                           {option.description}
                         </CardDescription>
                       </div>
                     </div>
                   </CardHeader>
                   <CardContent>
                     <ul className="space-y-2 text-sm text-muted-foreground">
                       {option.features.map((feature, i) => (
                         <li key={i} className="flex items-start gap-2">
                           <span className="text-primary mt-0.5">â€¢</span>
                           <span>{feature}</span>
                         </li>
                       ))}
                     </ul>
                   </CardContent>
                 </Card>
               </Label>
             ))}
           </RadioGroup>
         );
       }
       ```

    2. Create src/pages/WelcomePage.tsx:
       ```tsx
       import { useState } from 'react';
       import { Button } from '@/components/ui/button';
       import { ModeSelection } from '@/components/welcome/ModeCard';
       import { useWizardStore } from '@/stores/wizardStore';
       import type { Mode } from '@/types/wizard';

       interface WelcomePageProps {
         onProceed: () => void;
       }

       export function WelcomePage({ onProceed }: WelcomePageProps) {
         const { mode, setMode } = useWizardStore();
         const [selectedMode, setSelectedMode] = useState<Mode>(mode);

         const handleProceed = () => {
           setMode(selectedMode);
           onProceed();
         };

         return (
           <div className="min-h-screen bg-background">
             <div className="container max-w-4xl mx-auto px-4 py-12 md:py-20">
               {/* Header */}
               <div className="text-center mb-12">
                 <h1 className="text-4xl md:text-5xl font-bold tracking-tight mb-4">
                   Should I Test That?
                 </h1>
                 <p className="text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto">
                   Decide whether an A/B test is worth running by calculating the
                   maximum cost worth paying to eliminate decision uncertainty.
                 </p>
               </div>

               {/* Mode Selection */}
               <div className="mb-8">
                 <h2 className="text-lg font-medium text-center mb-6">
                   Choose your calculation mode
                 </h2>
                 <ModeSelection
                   selectedMode={selectedMode}
                   onModeSelect={setSelectedMode}
                 />
               </div>

               {/* Proceed Button */}
               <div className="flex justify-center">
                 <Button
                   size="lg"
                   onClick={handleProceed}
                   className="px-8"
                 >
                   Get Started
                 </Button>
               </div>

               {/* Footer note */}
               <p className="text-center text-sm text-muted-foreground mt-8">
                 You can switch modes anytime from the calculator.
               </p>
             </div>
           </div>
         );
       }
       ```

    3. Update src/App.tsx to use routing between Welcome and Calculator:
       ```tsx
       import { useState } from 'react';
       import { WelcomePage } from '@/pages/WelcomePage';

       type Page = 'welcome' | 'calculator';

       function App() {
         const [currentPage, setCurrentPage] = useState<Page>('welcome');

         if (currentPage === 'welcome') {
           return <WelcomePage onProceed={() => setCurrentPage('calculator')} />;
         }

         // Placeholder for Calculator page (implemented in 01-04)
         return (
           <div className="min-h-screen bg-background p-8">
             <h1 className="text-2xl font-bold mb-4">Calculator Page</h1>
             <p className="text-muted-foreground mb-4">
               (Calculator implementation coming in next plan)
             </p>
             <button
               onClick={() => setCurrentPage('welcome')}
               className="text-primary underline"
             >
               Back to Welcome
             </button>
           </div>
         );
       }

       export default App;
       ```

    4. Ensure all directory structure exists:
       ```bash
       mkdir -p src/pages src/components/welcome src/stores src/types
       ```
  </action>
  <verify>
    Run `npm run dev` and test:
    1. Welcome page shows with title "Should I Test That?"
    2. Two mode cards are visible (Basic Mode, Advanced Mode)
    3. Clicking a card selects it (ring/border highlights)
    4. "Get Started" button is clickable
    5. After clicking "Get Started", navigates to placeholder Calculator page
    6. Refresh on Calculator page, then go back to Welcome - mode selection persists

    Run `npm run build` - should compile without errors.
  </verify>
  <done>
    Welcome page implemented with two mode selection cards. Selecting a mode persists to Zustand store. "Get Started" navigates to Calculator page (placeholder).
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. Welcome page renders with header and two mode cards
2. Mode selection works (visual feedback on card selection)
3. Zustand store persists mode to sessionStorage
4. Navigation from Welcome to Calculator works
5. TypeScript compiles without errors
6. All imports use @/ path alias
7. Switching to Basic mode clears advanced-only inputs

Test sequence:
```bash
npm run build
npm run dev
# In browser:
# 1. Select Advanced, click Get Started, refresh, go back - Advanced still selected
# 2. Set some advanced input, switch to Basic - advanced inputs should reset
```
</verification>

<success_criteria>
- Zustand store manages mode + inputs with session persistence
- Welcome page shows two selectable mode cards
- Mode selection has clear visual feedback
- "Get Started" navigates to Calculator page
- Mode persists across page refresh (within session)
- Switching to Basic mode clears advanced-only inputs to initial values
- TypeScript strict mode passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-wizard-infrastructure/01-03-SUMMARY.md`
</output>
