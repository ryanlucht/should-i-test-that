---
phase: 06.1-calculation-bugs-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useEVSICalculations.ts
  - src/hooks/useEVSICalculations.test.ts
autonomous: true

must_haves:
  truths:
    - "Worker is terminated on component unmount"
    - "Worker is terminated if computation throws an error"
    - "Worker is terminated after successful completion"
    - "No memory leaks from orphaned Workers"
  artifacts:
    - path: "src/hooks/useEVSICalculations.ts"
      provides: "Proper Worker lifecycle management"
      contains: "finally"
  key_links:
    - from: "src/hooks/useEVSICalculations.ts"
      to: "worker.terminate()"
      via: "finally block and cleanup function"
      pattern: "worker\\.terminate"
---

<objective>
Fix Worker lifecycle cleanup to prevent memory leaks and orphaned Workers.

Purpose: The EVSI worker is only terminated after successful completion. If an exception occurs or the effect is invalidated during computation, the worker continues running as a memory leak.

Output: Proper Worker lifecycle with termination in finally block and effect cleanup.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/useEVSICalculations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Worker lifecycle in useEVSICalculations</name>
  <files>src/hooks/useEVSICalculations.ts</files>
  <action>
Refactor the Worker handling in the useEffect (around line 280-342) to properly manage lifecycle:

1. Move worker declaration to outer scope of runWorker function so cleanup can access it
2. Move termination to finally block to guarantee cleanup
3. Add worker termination to effect cleanup function

Replace the current implementation with:

```typescript
useEffect(() => {
  // Clear results if inputs become invalid
  if (!validatedInputs) {
    setWorkerResults(null);
    setLoading(false);
    return;
  }

  const { prior, evsiInputs } = validatedInputs;

  // For Normal priors, use fast path (synchronous, no Worker)
  if (prior.type === 'normal') {
    const results = calculateEVSINormalFastPath(evsiInputs);
    setWorkerResults(results);
    setLoading(false);
    return;
  }

  // For Student-t and Uniform, use Web Worker (async)
  setLoading(true);
  const currentRequestId = ++requestIdRef.current;

  // Worker reference for cleanup
  let worker: Worker | null = null;

  // Use native Worker with Comlink for type-safe RPC
  const runWorker = async () => {
    try {
      // Import Comlink dynamically
      const Comlink = await import('comlink');

      // Create native Worker using Vite's ?worker import
      worker = new Worker(
        new URL('../lib/workers/evsi.worker.ts', import.meta.url),
        { type: 'module' }
      );

      // Wrap with Comlink for type-safe RPC
      const api = Comlink.wrap<{ computeEVSI: (inputs: typeof evsiInputs, numSamples: number) => EVSIResults }>(worker);

      const results = await api.computeEVSI(evsiInputs, 5000);

      // Only update if this is still the current request
      if (currentRequestId === requestIdRef.current) {
        setWorkerResults(results);
        setLoading(false);
      }
    } catch (error) {
      console.error('EVSI Worker error:', error);
      if (currentRequestId === requestIdRef.current) {
        setWorkerResults(null);
        setLoading(false);
      }
    } finally {
      // Always terminate the worker when done or on error
      if (worker) {
        worker.terminate();
        worker = null;
      }
    }
  };

  runWorker();

  // Cleanup: terminate worker if still running and invalidate request
  return () => {
    requestIdRef.current++;
    if (worker) {
      worker.terminate();
      worker = null;
    }
  };
}, [validatedInputs]);
```

Key changes:
1. `worker` is declared in outer scope with `let worker: Worker | null = null`
2. `worker.terminate()` moved to `finally` block (always runs)
3. Cleanup function also terminates worker if still running
4. Worker set to null after termination for safety
  </action>
  <verify>Run `npm run typecheck` - no type errors. Run `npm run test -- useEVSI` - tests pass</verify>
  <done>Worker is properly terminated on success, error, and unmount - no memory leaks</done>
</task>

<task type="auto">
  <name>Task 2: Verify existing tests still pass</name>
  <files>src/hooks/useEVSICalculations.test.ts</files>
  <action>
Run existing tests to confirm the refactor doesn't break functionality:

1. Run `npm run test -- useEVSICalculations`
2. If any tests fail due to timing/mock issues with the new structure, update them to work with the finally-based cleanup

The existing tests should continue to pass since the behavior is the same - only the cleanup timing has changed. If Worker mocking needs adjustment, ensure mocks properly simulate the terminate() method.

No new tests needed - this is a structural refactor for cleanup, not new behavior.
  </action>
  <verify>Run `npm run test -- useEVSICalculations` - all existing tests pass</verify>
  <done>Existing test suite passes with Worker lifecycle changes</done>
</task>

</tasks>

<verification>
1. `npm run test -- useEVSICalculations` - Hook tests pass
2. `npm run typecheck` - No type errors
3. `npm run lint` - No lint errors
4. Manual test: Open Advanced mode, change inputs rapidly, check browser DevTools for Worker memory (should not accumulate)
</verification>

<success_criteria>
- Worker terminated in finally block (handles both success and error)
- Effect cleanup function terminates worker if still running
- No orphaned Workers on rapid input changes or unmount
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-calculation-bugs-polish/06.1-02-SUMMARY.md`
</output>
