---
phase: 06.1-calculation-bugs-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/calculations/evsi.ts
  - src/lib/calculations/evsi.test.ts
autonomous: true

must_haves:
  truths:
    - "Monte Carlo EVSI calculates payoff relative to threshold (K * (L_true - T_L)), not absolute lift"
    - "Zero valid samples edge case returns EVSI=0 with probabilityTestChangesDecision=0"
    - "EVSI calculation is consistent with EVPI formula's threshold-relative approach"
  artifacts:
    - path: "src/lib/calculations/evsi.ts"
      provides: "Fixed Monte Carlo payoff calculation"
      contains: "K * (L_true - threshold_L)"
    - path: "src/lib/calculations/evsi.test.ts"
      provides: "Test coverage for threshold payoff and zero samples edge case"
  key_links:
    - from: "src/lib/calculations/evsi.ts"
      to: "valueWithoutTest/valueWithTest"
      via: "threshold_L subtraction in payoff"
      pattern: "K \\* \\(L_true - threshold_L\\)"
---

<objective>
Fix critical EVSI calculation bugs that cause incorrect values.

Purpose: The Monte Carlo EVSI ignores the threshold in payoff calculation, systematically overstating EVSI when T_L > 0 and understating when T_L < 0. Additionally, division by zero can occur when all samples are rejected.

Output: Corrected evsi.ts with threshold-relative payoffs and safe handling of zero valid samples.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/calculations/evsi.ts
@src/lib/calculations/evsi.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Monte Carlo EVSI threshold payoff calculation</name>
  <files>src/lib/calculations/evsi.ts</files>
  <action>
In calculateEVSIMonteCarlo(), fix the payoff calculation to use threshold-relative values:

1. Change valueWithoutTest calculation (around line 144-151):
```typescript
// BEFORE (incorrect):
if (defaultDecision === 'ship') {
  valueWithoutTest = K * L_true;
} else {
  valueWithoutTest = 0;
}

// AFTER (correct - threshold-relative):
if (defaultDecision === 'ship') {
  // We ship, get value relative to threshold baseline
  // Value = K * (L_true - T_L) represents excess value above threshold
  valueWithoutTest = K * (L_true - threshold_L);
} else {
  // We don't ship, get 0 (threshold defines our baseline)
  valueWithoutTest = 0;
}
```

2. Change valueWithTest calculation (around line 180-184):
```typescript
// BEFORE (incorrect):
if (posteriorDecision === 'ship') {
  valueWithTest = K * L_true;
} else {
  valueWithTest = 0;
}

// AFTER (correct - threshold-relative):
if (posteriorDecision === 'ship') {
  // Ship based on test result, get threshold-relative value
  valueWithTest = K * (L_true - threshold_L);
} else {
  // Don't ship based on test result
  valueWithTest = 0;
}
```

The mathematical rationale: Value is measured relative to the threshold because:
- Shipping when L_true > T_L gives positive value (correct decision)
- Shipping when L_true < T_L gives negative value (regret)
- Not shipping always gives 0 (threshold is our baseline)

This aligns with the EVPI formula which uses threshold-relative calculations.
  </action>
  <verify>Run `npm run test -- evsi` - existing tests should still pass (they may need updates if they were testing incorrect behavior)</verify>
  <done>Monte Carlo EVSI uses K * (L_true - threshold_L) for ship payoffs, consistent with EVPI formula approach</done>
</task>

<task type="auto">
  <name>Task 2: Fix zero valid samples edge case</name>
  <files>src/lib/calculations/evsi.ts</files>
  <action>
In calculateEVSIMonteCarlo(), add a guard after the Monte Carlo loop to handle zero valid samples:

After the while loop (around line 188) and BEFORE the division (around line 193), add:

```typescript
// ===========================================
// Guard: Handle zero valid samples edge case
// ===========================================
// If feasibility filter rejected all draws (e.g., very tight CR0 constraints
// with wide prior), validSamples can be 0. Return safe "no information" result.
if (validSamples === 0) {
  return {
    evsiDollars: 0,
    defaultDecision,
    probabilityClearsThreshold: probClearsThreshold,
    probabilityTestChangesDecision: 0,
    numSamples: 0,
    numRejected: rejectedSamples,
  };
}
```

This prevents NaN from division by zero and returns a sensible result indicating no information was gained (because we couldn't generate any feasible samples).
  </action>
  <verify>Run `npm run test -- evsi` - tests should pass</verify>
  <done>Zero valid samples returns safe result with EVSI=0 and probabilityTestChangesDecision=0</done>
</task>

<task type="auto">
  <name>Task 3: Add test coverage for fixes</name>
  <files>src/lib/calculations/evsi.test.ts</files>
  <action>
Add tests to verify both fixes:

1. Add test for threshold-relative payoff behavior:
```typescript
describe('Monte Carlo EVSI threshold handling', () => {
  it('should calculate payoff relative to threshold, not absolute lift', () => {
    // Test with a positive threshold (minimum-lift scenario)
    const inputsWithThreshold: EVSIInputs = {
      K: 100000,
      baselineConversionRate: 0.05,
      threshold_L: 0.02, // 2% threshold
      prior: { type: 'uniform', low_L: -0.05, high_L: 0.10 },
      n_control: 5000,
      n_variant: 5000,
    };

    const result = calculateEVSIMonteCarlo(inputsWithThreshold, 5000);

    // EVSI should be positive but smaller than with threshold=0
    // because some positive lifts (0 < L < 0.02) don't clear threshold
    expect(result.evsiDollars).toBeGreaterThanOrEqual(0);

    // Compare with zero threshold
    const inputsZeroThreshold: EVSIInputs = {
      ...inputsWithThreshold,
      threshold_L: 0,
    };
    const resultZero = calculateEVSIMonteCarlo(inputsZeroThreshold, 5000);

    // With same prior centered on positive lift, higher threshold should
    // generally yield lower or equal EVSI (more samples below threshold)
    // This is a sanity check, not a strict mathematical guarantee
    expect(result.evsiDollars).toBeLessThanOrEqual(resultZero.evsiDollars * 1.5);
  });
});
```

2. Add test for zero valid samples edge case:
```typescript
describe('Monte Carlo EVSI edge cases', () => {
  it('should return safe result when all samples are rejected (zero valid)', () => {
    // Create inputs where feasibility constraint rejects most/all samples
    // High CR0 (0.99) means L_max = 1/0.99 - 1 = ~0.01
    // Prior with wide positive range will mostly fail feasibility
    const extremeInputs: EVSIInputs = {
      K: 100000,
      baselineConversionRate: 0.99, // Very high CR0
      threshold_L: 0,
      prior: { type: 'uniform', low_L: 0.05, high_L: 0.50 }, // All above L_max!
      n_control: 1000,
      n_variant: 1000,
    };

    // This should not throw and should return safe zero result
    const result = calculateEVSIMonteCarlo(extremeInputs, 100);

    expect(result.evsiDollars).toBe(0);
    expect(result.probabilityTestChangesDecision).toBe(0);
    expect(result.numSamples).toBe(0);
    expect(result.numRejected).toBeGreaterThan(0);
    expect(Number.isNaN(result.evsiDollars)).toBe(false);
  });
});
```

Import calculateEVSIMonteCarlo if not already imported in the test file.
  </action>
  <verify>Run `npm run test -- evsi` - all tests including new ones should pass</verify>
  <done>Test coverage exists for threshold-relative payoff and zero valid samples edge case</done>
</task>

</tasks>

<verification>
1. `npm run test -- evsi` - All EVSI tests pass
2. `npm run lint` - No lint errors
3. `npm run typecheck` - No type errors
</verification>

<success_criteria>
- Monte Carlo EVSI correctly uses K * (L_true - threshold_L) for shipping payoff
- Zero valid samples returns EVSI=0 without NaN or division by zero
- All tests pass including new edge case coverage
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-calculation-bugs-polish/06.1-01-SUMMARY.md`
</output>
