---
phase: 03-calculation-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/calculations/types.ts
  - src/lib/calculations/statistics.ts
  - src/lib/calculations/statistics.test.ts
  - src/lib/calculations/derived.ts
  - src/lib/calculations/derived.test.ts
  - src/lib/formatting.ts
  - src/lib/formatting.test.ts
autonomous: true

must_haves:
  truths:
    - "standardNormalPDF returns correct values for z-scores"
    - "standardNormalCDF returns probabilities in [0,1] with high accuracy"
    - "deriveK correctly multiplies N_year * CR0 * V"
    - "normalizeThresholdToLift handles both dollar and lift units"
    - "formatSmartCurrency displays $127, $12.7K, $1.27M appropriately"
  artifacts:
    - path: "src/lib/calculations/types.ts"
      provides: "EVPIInputs, EVPIResults, EdgeCaseFlags interfaces"
      exports: ["EVPIInputs", "EVPIResults", "EdgeCaseFlags"]
    - path: "src/lib/calculations/statistics.ts"
      provides: "Standard normal PDF/CDF functions"
      exports: ["standardNormalPDF", "standardNormalCDF"]
    - path: "src/lib/calculations/derived.ts"
      provides: "K derivation and threshold conversion"
      exports: ["deriveK", "normalizeThresholdToLift", "determineDefaultDecision"]
    - path: "src/lib/formatting.ts"
      provides: "Smart currency formatting for outputs"
      exports: ["formatSmartCurrency"]
  key_links:
    - from: "src/lib/calculations/statistics.ts"
      to: "Mathematical constants"
      via: "SQRT_2_PI constant"
      pattern: "Math\\.sqrt\\(2 \\* Math\\.PI\\)"
    - from: "src/lib/calculations/derived.ts"
      to: "threshold conversion"
      via: "normalizeThresholdToLift function"
      pattern: "thresholdValue \\/ K"
---

<objective>
Implement foundational calculation primitives for EVPI computation.

Purpose: Establish the mathematical building blocks (standard normal PDF/CDF, K derivation, threshold conversion) that the EVPI calculation will use. These are pure functions with well-defined inputs/outputs, ideal for TDD.

Output: Tested statistics functions, derived value functions, and smart currency formatting.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-calculation-engine/03-CONTEXT.md
@.planning/phases/03-calculation-engine/03-RESEARCH.md
@SPEC.md (Section 4: Notation/units, Section 8.1-8.3: Calculations)
@src/lib/prior.ts (existing prior utilities pattern)
@src/lib/formatting.ts (existing formatting utilities)
@src/types/wizard.ts (SharedInputs interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and statistics functions with TDD</name>
  <files>
    src/lib/calculations/types.ts
    src/lib/calculations/statistics.ts
    src/lib/calculations/statistics.test.ts
  </files>
  <action>
**RED phase:** Create test file first with failing tests.

Create `src/lib/calculations/types.ts`:
```typescript
/**
 * Input types for EVPI calculation
 * All values should be in their canonical forms:
 * - Rates as decimals (0.032 not 3.2%)
 * - Lift as decimals (0.05 not 5%)
 */
export interface EVPIInputs {
  baselineConversionRate: number;  // CR0 as decimal
  annualVisitors: number;          // N_year
  valuePerConversion: number;      // V in dollars
  prior: { mu_L: number; sigma_L: number };  // Prior parameters
  threshold_L: number;             // T_L as decimal
}

export interface EVPIResults {
  evpiDollars: number;
  defaultDecision: 'ship' | 'dont-ship';
  probabilityClearsThreshold: number;  // P(L >= T_L)
  chanceOfBeingWrong: number;
  // Derived values for debugging panel
  K: number;
  threshold_dollars: number;
  zScore: number;
  phiZ: number;
  PhiZ: number;
  // Edge case flags
  edgeCases: EdgeCaseFlags;
}

export interface EdgeCaseFlags {
  truncationApplied: boolean;
  nearZeroSigma: boolean;
  priorOneSided: boolean;
}
```

Create `src/lib/calculations/statistics.test.ts` with tests:
- `standardNormalPDF(0)` should return approximately 0.3989 (1/sqrt(2*pi))
- `standardNormalPDF(1)` should return approximately 0.2420
- `standardNormalPDF(-1)` should equal `standardNormalPDF(1)` (symmetry)
- `standardNormalCDF(0)` should return 0.5
- `standardNormalCDF(-Infinity)` should return 0
- `standardNormalCDF(Infinity)` should return 1
- `standardNormalCDF(1.6448536)` should return approximately 0.95 (z_0.95)
- `standardNormalCDF(-1.6448536)` should return approximately 0.05

**GREEN phase:** Implement `src/lib/calculations/statistics.ts`:
- Use Abramowitz-Stegun approximation for CDF (error < 7.5e-8)
- Hand-roll PDF using Math.exp(-0.5 * z * z) / sqrt(2*pi)
- Add JSDoc comments explaining the mathematical formulas
- Export SQRT_2_PI constant for reuse

Implementation per 03-RESEARCH.md code examples.
  </action>
  <verify>
Run `npm test src/lib/calculations/statistics.test.ts` - all tests pass.
Verify PDF/CDF values match known statistical tables within tolerance (1e-6).
  </verify>
  <done>
- standardNormalPDF returns correct values for z = -3 to +3
- standardNormalCDF returns probabilities matching z-tables
- Functions handle edge cases (very large/small z values)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create derived value functions with TDD</name>
  <files>
    src/lib/calculations/derived.ts
    src/lib/calculations/derived.test.ts
  </files>
  <action>
**RED phase:** Create test file with failing tests.

Create `src/lib/calculations/derived.test.ts` with tests:

For `deriveK`:
- K = 1,000,000 visitors * 0.05 CR * $100 value = $5,000,000
- K = 500,000 visitors * 0.03 CR * $50 value = $750,000
- K with zero inputs returns 0 (defensive)

For `normalizeThresholdToLift`:
- Dollar threshold: $50,000 with K=$1,000,000 -> T_L = 0.05
- Lift threshold: 5 (percentage) -> T_L = 0.05
- Dollar threshold with K=0 returns 0 (defensive)

For `determineDefaultDecision`:
- mu_L = 0.05, T_L = 0.03 -> 'ship' (mean above threshold)
- mu_L = 0.02, T_L = 0.05 -> 'dont-ship' (mean below threshold)
- mu_L = 0.05, T_L = 0.05 -> 'ship' (mean equals threshold, tie goes to ship)

For `detectEdgeCases`:
- sigma_L = 0.0001 -> nearZeroSigma = true
- sigma_L = 0.05 -> nearZeroSigma = false
- Phi(z) = 0.99999 -> priorOneSided = true
- Prior with mu_L = 0, sigma_L = 0.05 has negligible mass below -1 -> truncationApplied = false
- Prior with mu_L = -0.8, sigma_L = 0.2 has significant mass below -1 -> truncationApplied = true

**GREEN phase:** Implement `src/lib/calculations/derived.ts`:

```typescript
import { standardNormalCDF } from './statistics';

/**
 * Derive K (annual dollars per unit lift)
 * K = N_year * CR0 * V
 *
 * Per SPEC.md Section 4.2: "dollar scaling constant"
 */
export function deriveK(
  annualVisitors: number,
  baselineConversionRate: number,
  valuePerConversion: number
): number {
  return annualVisitors * baselineConversionRate * valuePerConversion;
}

/**
 * Convert threshold to lift units (decimal)
 *
 * Per SPEC.md Section 7.2: T_L = T_$ / K
 *
 * @param thresholdValue - Value in stored unit
 * @param thresholdUnit - 'dollars' or 'lift'
 * @param K - Annual dollars per unit lift
 * @returns T_L as decimal (e.g., 0.05 for 5% lift)
 */
export function normalizeThresholdToLift(
  thresholdValue: number,
  thresholdUnit: 'dollars' | 'lift',
  K: number
): number {
  if (thresholdUnit === 'dollars') {
    return K > 0 ? thresholdValue / K : 0;
  }
  // Lift is stored as percentage (5 for 5%), convert to decimal
  return thresholdValue / 100;
}

/**
 * Determine default decision based on prior mean vs threshold
 *
 * Per SPEC.md Section 8.1: "if mu_L >= T_L: Ship, else Don't ship"
 */
export function determineDefaultDecision(
  mu_L: number,
  T_L: number
): 'ship' | 'dont-ship' {
  return mu_L >= T_L ? 'ship' : 'dont-ship';
}

/**
 * Detect edge cases that require special UI messaging
 *
 * Per 03-CONTEXT.md: Show educational notes for edge cases
 */
export function detectEdgeCases(
  sigma_L: number,
  mu_L: number,
  Phi_z: number
): EdgeCaseFlags {
  // Near-zero sigma: user is essentially certain
  const nearZeroSigma = sigma_L < 0.001;

  // Prior one-sided: essentially all mass on one side of threshold
  const priorOneSided = Phi_z > 0.9999 || Phi_z < 0.0001;

  // Truncation: check if untruncated prior has mass below L = -1
  const z_minus1 = (-1 - mu_L) / sigma_L;
  const probBelowMinus1 = standardNormalCDF(z_minus1);
  const truncationApplied = probBelowMinus1 > 0.001;

  return { nearZeroSigma, priorOneSided, truncationApplied };
}
```

Import `EdgeCaseFlags` type from types.ts.
  </action>
  <verify>
Run `npm test src/lib/calculations/derived.test.ts` - all tests pass.
  </verify>
  <done>
- deriveK correctly computes K = N_year * CR0 * V
- normalizeThresholdToLift handles both dollar and lift units
- determineDefaultDecision returns correct decision based on mu_L vs T_L
- detectEdgeCases identifies near-zero sigma, one-sided prior, and truncation
  </done>
</task>

<task type="auto">
  <name>Task 3: Add smart currency formatting with TDD</name>
  <files>
    src/lib/formatting.ts
    src/lib/formatting.test.ts
  </files>
  <action>
**RED phase:** Add tests to existing or new test file.

Create/update `src/lib/formatting.test.ts` with tests for `formatSmartCurrency`:
- $127 -> "$127" (small amounts, no decimals)
- $999 -> "$999"
- $1,000 -> "$1K" or "$1.00K" (compact notation)
- $12,700 -> "$12.7K"
- $127,000 -> "$127K"
- $1,270,000 -> "$1.27M"
- $12,700,000 -> "$12.7M"
- $0 -> "$0"
- Negative values: -$5,000 -> "-$5K"

**GREEN phase:** Add to `src/lib/formatting.ts`:

```typescript
/**
 * Smart dollar formatting for EVPI/EVSI outputs
 *
 * Per 03-CONTEXT.md:
 * - $127 for small amounts (< 1000)
 * - $12.7K for thousands
 * - $1.27M for millions
 *
 * Uses Intl.NumberFormat compact notation for natural display.
 */
export function formatSmartCurrency(value: number): string {
  // For values under $1000, show exact dollars (no decimals)
  if (Math.abs(value) < 1000) {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      maximumFractionDigits: 0,
    }).format(value);
  }

  // For larger values, use compact notation
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    notation: 'compact',
    maximumSignificantDigits: 3,
  }).format(value);
}
```

Note: Intl.NumberFormat compact notation behavior varies slightly by browser/Node version. Tests should use `.toContain()` or regex matching rather than exact string equality for the K/M suffix format.
  </action>
  <verify>
Run `npm test src/lib/formatting.test.ts` - all tests pass.
Run `npm run lint` - no errors.
  </verify>
  <done>
- formatSmartCurrency returns "$127" for values under $1000
- formatSmartCurrency returns compact notation ("$12.7K", "$1.27M") for larger values
- Function handles zero and negative values correctly
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test` - all new tests pass
2. `npm run lint` - no lint errors
3. `npm run build` - builds successfully
4. Verify exported functions are importable from their modules
</verification>

<success_criteria>
- [x] Types defined: EVPIInputs, EVPIResults, EdgeCaseFlags
- [x] standardNormalPDF and standardNormalCDF implemented with high accuracy
- [x] deriveK, normalizeThresholdToLift, determineDefaultDecision work correctly
- [x] detectEdgeCases identifies all three edge case types
- [x] formatSmartCurrency displays appropriate compact notation
- [x] All functions are pure (no side effects)
- [x] All functions have JSDoc comments explaining the math
- [x] Test coverage for all functions
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculation-engine/03-01-SUMMARY.md`
</output>
