---
phase: 03-calculation-engine
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/calculations/evpi.ts
  - src/lib/calculations/evpi.test.ts
autonomous: true

must_haves:
  truths:
    - "EVPI is calculated correctly using closed-form Normal formula"
    - "EVPI approaches zero when sigma_L approaches zero"
    - "EVPI approaches zero when prior is entirely on one side of threshold"
    - "Probability of clearing threshold P(L >= T_L) is computed correctly"
    - "Chance of being wrong depends on default decision"
  artifacts:
    - path: "src/lib/calculations/evpi.ts"
      provides: "EVPI calculation engine"
      exports: ["calculateEVPI"]
      min_lines: 80
  key_links:
    - from: "src/lib/calculations/evpi.ts"
      to: "src/lib/calculations/statistics.ts"
      via: "imports standardNormalPDF, standardNormalCDF"
      pattern: "import.*standardNormal"
    - from: "src/lib/calculations/evpi.ts"
      to: "src/lib/calculations/derived.ts"
      via: "imports deriveK, determineDefaultDecision, detectEdgeCases"
      pattern: "import.*deriveK"
---

<objective>
Implement the EVPI calculation using the closed-form Normal formula.

Purpose: This is the core calculation that transforms user inputs into the "max cost worth paying" threshold. Uses the mathematical formulas from SPEC.md Section 8.4.

Output: A single `calculateEVPI` function that takes business inputs + prior + threshold and returns EVPI with all supporting metrics.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-calculation-engine/03-CONTEXT.md
@.planning/phases/03-calculation-engine/03-RESEARCH.md
@.planning/phases/03-calculation-engine/03-01-SUMMARY.md
@SPEC.md (Section 8.4: EVPI computation approach)
@src/lib/calculations/types.ts
@src/lib/calculations/statistics.ts
@src/lib/calculations/derived.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write EVPI tests (RED phase)</name>
  <files>
    src/lib/calculations/evpi.test.ts
  </files>
  <action>
Create comprehensive tests for EVPI calculation based on SPEC.md Section 8.4.

**Test categories:**

1. **Basic functionality tests:**
```typescript
describe('calculateEVPI', () => {
  it('returns correct structure with all required fields', () => {
    const result = calculateEVPI({
      baselineConversionRate: 0.05,
      annualVisitors: 1000000,
      valuePerConversion: 100,
      prior: { mu_L: 0, sigma_L: 0.05 },
      threshold_L: 0,
    });
    expect(result).toHaveProperty('evpiDollars');
    expect(result).toHaveProperty('defaultDecision');
    expect(result).toHaveProperty('probabilityClearsThreshold');
    expect(result).toHaveProperty('chanceOfBeingWrong');
    expect(result).toHaveProperty('K');
    expect(result).toHaveProperty('zScore');
    expect(result).toHaveProperty('phiZ');
    expect(result).toHaveProperty('PhiZ');
    expect(result).toHaveProperty('edgeCases');
  });
});
```

2. **Default decision tests:**
```typescript
it('returns "ship" when mu_L >= T_L', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0.05, sigma_L: 0.05 },  // mean = 5%
    threshold_L: 0,  // threshold = 0%
  });
  expect(result.defaultDecision).toBe('ship');
});

it('returns "dont-ship" when mu_L < T_L', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0, sigma_L: 0.05 },  // mean = 0%
    threshold_L: 0.05,  // threshold = 5%
  });
  expect(result.defaultDecision).toBe('dont-ship');
});
```

3. **EVPI formula verification tests:**

For the default prior N(0, 0.05) with T_L = 0:
- z = (0 - 0) / 0.05 = 0
- Phi(0) = 0.5
- phi(0) = 0.3989...
- Default decision = Ship (since mu_L >= T_L)
- EVPI = K * [ (T_L - mu_L) * Phi(z) + sigma_L * phi(z) ]
- EVPI = K * [ 0 * 0.5 + 0.05 * 0.3989 ]
- EVPI = K * 0.01995 (approximately)

With K = 1,000,000 * 0.05 * 100 = 5,000,000:
- EVPI = 5,000,000 * 0.01995 = ~$99,735

```typescript
it('calculates correct EVPI for default prior with zero threshold', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0, sigma_L: 0.05 },
    threshold_L: 0,
  });

  // K = 1,000,000 * 0.05 * 100 = 5,000,000
  expect(result.K).toBe(5000000);

  // z = (0 - 0) / 0.05 = 0
  expect(result.zScore).toBeCloseTo(0, 6);

  // phi(0) ≈ 0.3989
  expect(result.phiZ).toBeCloseTo(0.3989, 3);

  // Phi(0) = 0.5
  expect(result.PhiZ).toBeCloseTo(0.5, 6);

  // EVPI = K * sigma_L * phi(0) = 5,000,000 * 0.05 * 0.3989 ≈ 99,735
  expect(result.evpiDollars).toBeCloseTo(99735, -2);  // within $100
});
```

4. **Edge case tests:**
```typescript
it('returns EVPI near zero when sigma_L is very small', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0.05, sigma_L: 0.0001 },  // very narrow prior
    threshold_L: 0,
  });
  expect(result.evpiDollars).toBeLessThan(100);  // essentially zero
  expect(result.edgeCases.nearZeroSigma).toBe(true);
});

it('returns EVPI near zero when prior is far above threshold', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0.20, sigma_L: 0.02 },  // prior centered at 20%
    threshold_L: 0,  // threshold at 0%
  });
  // Prior is ~10 sigma above threshold, essentially no regret region
  expect(result.evpiDollars).toBeLessThan(100);
  expect(result.edgeCases.priorOneSided).toBe(true);
});

it('sets truncationApplied when prior has mass below L=-1', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: -0.8, sigma_L: 0.2 },  // wide prior near -100%
    threshold_L: 0,
  });
  expect(result.edgeCases.truncationApplied).toBe(true);
});
```

5. **Probability calculations:**
```typescript
it('calculates probability of clearing threshold correctly', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0, sigma_L: 0.05 },
    threshold_L: 0,
  });
  // P(L >= 0) = 1 - Phi(0) = 0.5
  expect(result.probabilityClearsThreshold).toBeCloseTo(0.5, 6);
});

it('calculates chance of being wrong based on default decision', () => {
  // When default is Ship, chance of being wrong = P(L < T_L)
  const shipResult = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0.05, sigma_L: 0.05 },
    threshold_L: 0,
  });
  // P(L < 0) when mu_L = 0.05, sigma_L = 0.05
  // z = (0 - 0.05) / 0.05 = -1
  // P(L < 0) = Phi(-1) ≈ 0.159
  expect(shipResult.chanceOfBeingWrong).toBeCloseTo(0.159, 2);

  // When default is Don't ship, chance of being wrong = P(L >= T_L)
  const dontShipResult = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0, sigma_L: 0.05 },
    threshold_L: 0.05,  // threshold above mean
  });
  // P(L >= 0.05) when mu_L = 0, sigma_L = 0.05
  // z = (0.05 - 0) / 0.05 = 1
  // P(L >= 0.05) = 1 - Phi(1) ≈ 0.159
  expect(dontShipResult.chanceOfBeingWrong).toBeCloseTo(0.159, 2);
});
```

6. **Threshold dollar conversion:**
```typescript
it('calculates threshold_dollars from threshold_L and K', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0, sigma_L: 0.05 },
    threshold_L: 0.05,  // 5% lift
  });
  // K = 5,000,000
  // T_$ = K * T_L = 5,000,000 * 0.05 = 250,000
  expect(result.threshold_dollars).toBe(250000);
});
```

Run tests - they should all FAIL (function doesn't exist yet).
  </action>
  <verify>
Run `npm test src/lib/calculations/evpi.test.ts` - tests fail with "function not found" errors.
  </verify>
  <done>
Comprehensive test suite created covering:
- Basic structure and return types
- Default decision logic
- EVPI formula accuracy
- Edge cases (near-zero sigma, one-sided prior, truncation)
- Probability calculations
- Threshold dollar conversion
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement EVPI calculation (GREEN phase)</name>
  <files>
    src/lib/calculations/evpi.ts
  </files>
  <action>
Implement the `calculateEVPI` function to make all tests pass.

Create `src/lib/calculations/evpi.ts`:

```typescript
/**
 * EVPI Calculation Engine
 *
 * Implements the Expected Value of Perfect Information calculation
 * using the closed-form Normal formula from SPEC.md Section 8.4.
 *
 * EVPI represents the maximum amount worth paying to eliminate
 * decision uncertainty - the "perfect crystal ball" ceiling.
 */

import { standardNormalPDF, standardNormalCDF } from './statistics';
import { deriveK, determineDefaultDecision, detectEdgeCases } from './derived';
import type { EVPIInputs, EVPIResults } from './types';

/**
 * Calculate EVPI and supporting metrics for Basic mode
 *
 * Uses closed-form Normal formula per SPEC.md Section 8.4:
 *
 * If default decision is Ship:
 *   EVPI = K * [ (T_L - mu_L) * Phi(z) + sigma_L * phi(z) ]
 *
 * If default decision is Don't ship:
 *   EVPI = K * [ (mu_L - T_L) * (1 - Phi(z)) + sigma_L * phi(z) ]
 *
 * Where:
 *   z = (T_L - mu_L) / sigma_L  (standardized threshold)
 *   phi(z) = standard normal PDF
 *   Phi(z) = standard normal CDF
 *   K = N_year * CR0 * V (annual dollars per unit lift)
 *
 * @param inputs - Business inputs, prior parameters, and threshold
 * @returns EVPI results with all supporting metrics
 */
export function calculateEVPI(inputs: EVPIInputs): EVPIResults {
  const {
    baselineConversionRate,
    annualVisitors,
    valuePerConversion,
    prior,
    threshold_L,
  } = inputs;

  const { mu_L, sigma_L } = prior;

  // Step 1: Derive K (annual dollars per unit lift)
  // Per SPEC.md Section 4.2: K = N_year * CR0 * V
  const K = deriveK(annualVisitors, baselineConversionRate, valuePerConversion);

  // Step 2: Determine default decision
  // Per SPEC.md Section 8.1: Ship if mu_L >= T_L
  const defaultDecision = determineDefaultDecision(mu_L, threshold_L);

  // Step 3: Calculate z-score (standardized threshold)
  // z = (T_L - mu_L) / sigma_L
  const zScore = sigma_L > 0 ? (threshold_L - mu_L) / sigma_L : 0;

  // Step 4: Calculate standard normal PDF and CDF at z
  const phiZ = standardNormalPDF(zScore);
  const PhiZ = standardNormalCDF(zScore);

  // Step 5: Calculate EVPI using closed-form formula
  // The formula differs based on the default decision
  let evpiDollars: number;

  if (defaultDecision === 'ship') {
    // EVPI = K * [ (T_L - mu_L) * Phi(z) + sigma_L * phi(z) ]
    // This is the expected regret from shipping when we shouldn't
    evpiDollars = K * ((threshold_L - mu_L) * PhiZ + sigma_L * phiZ);
  } else {
    // EVPI = K * [ (mu_L - T_L) * (1 - Phi(z)) + sigma_L * phi(z) ]
    // This is the expected regret from not shipping when we should
    evpiDollars = K * ((mu_L - threshold_L) * (1 - PhiZ) + sigma_L * phiZ);
  }

  // Step 6: Calculate probability of clearing threshold
  // P(L >= T_L) = 1 - Phi(z)
  const probabilityClearsThreshold = 1 - PhiZ;

  // Step 7: Calculate chance of being wrong
  // Per SPEC.md Section 8.5:
  // - If default Ship: P(wrong) = P(L < T_L) = Phi(z)
  // - If default Don't: P(wrong) = P(L >= T_L) = 1 - Phi(z)
  const chanceOfBeingWrong =
    defaultDecision === 'ship' ? PhiZ : 1 - PhiZ;

  // Step 8: Detect edge cases for UI messaging
  const edgeCases = detectEdgeCases(sigma_L, mu_L, PhiZ);

  // Step 9: Calculate threshold in dollars
  // T_$ = K * T_L
  const threshold_dollars = K * threshold_L;

  return {
    evpiDollars,
    defaultDecision,
    probabilityClearsThreshold,
    chanceOfBeingWrong,
    K,
    threshold_dollars,
    zScore,
    phiZ,
    PhiZ,
    edgeCases,
  };
}
```

Add barrel export in `src/lib/calculations/index.ts`:
```typescript
export * from './types';
export * from './statistics';
export * from './derived';
export * from './evpi';
```
  </action>
  <verify>
Run `npm test src/lib/calculations/evpi.test.ts` - all tests pass.
Run `npm run lint` - no lint errors.
Run `npm run build` - builds successfully.
  </verify>
  <done>
- calculateEVPI returns correct EVPI values using closed-form formula
- All test cases pass including edge cases
- Function handles both Ship and Don't Ship default decisions correctly
- Edge case flags are set appropriately
- All intermediate values (K, z, phi, Phi) are exposed for debugging
  </done>
</task>

<task type="auto">
  <name>Task 3: Add additional formula verification and refactor</name>
  <files>
    src/lib/calculations/evpi.ts
    src/lib/calculations/evpi.test.ts
  </files>
  <action>
**REFACTOR phase:** Verify formula correctness and add any needed refinements.

1. **Add a sanity check test comparing to manual calculation:**
```typescript
it('matches hand-calculated EVPI for a specific scenario', () => {
  // Scenario:
  // - 1M annual visitors, 5% CR, $100 per conversion
  // - K = 5,000,000
  // - Prior: N(0.02, 0.03) - expecting 2% lift with SD 3%
  // - Threshold: 1% lift

  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: 0.02, sigma_L: 0.03 },
    threshold_L: 0.01,
  });

  // K = 5,000,000
  // z = (0.01 - 0.02) / 0.03 = -0.333...
  // phi(-0.333) ≈ 0.3778
  // Phi(-0.333) ≈ 0.3694
  // Default: Ship (mu_L=0.02 > T_L=0.01)
  // EVPI = K * [ (T_L - mu_L) * Phi(z) + sigma_L * phi(z) ]
  //      = 5,000,000 * [ (-0.01) * 0.3694 + 0.03 * 0.3778 ]
  //      = 5,000,000 * [ -0.003694 + 0.011334 ]
  //      = 5,000,000 * 0.00764
  //      ≈ 38,200

  expect(result.K).toBe(5000000);
  expect(result.defaultDecision).toBe('ship');
  expect(result.zScore).toBeCloseTo(-0.333, 2);
  expect(result.evpiDollars).toBeCloseTo(38200, -2);  // within $100
});
```

2. **Add test for "Don't Ship" scenario formula:**
```typescript
it('calculates EVPI correctly when default is dont-ship', () => {
  const result = calculateEVPI({
    baselineConversionRate: 0.05,
    annualVisitors: 1000000,
    valuePerConversion: 100,
    prior: { mu_L: -0.02, sigma_L: 0.03 },  // expecting -2% lift
    threshold_L: 0.01,  // threshold 1%
  });

  // Default: Don't ship (mu_L=-0.02 < T_L=0.01)
  // z = (0.01 - (-0.02)) / 0.03 = 1.0
  // EVPI = K * [ (mu_L - T_L) * (1 - Phi(z)) + sigma_L * phi(z) ]
  //      = 5,000,000 * [ (-0.03) * (1 - 0.8413) + 0.03 * 0.2420 ]
  //      = 5,000,000 * [ (-0.03) * 0.1587 + 0.00726 ]
  //      = 5,000,000 * [ -0.00476 + 0.00726 ]
  //      = 5,000,000 * 0.0025
  //      ≈ 12,500

  expect(result.defaultDecision).toBe('dont-ship');
  expect(result.zScore).toBeCloseTo(1.0, 2);
  expect(result.evpiDollars).toBeCloseTo(12500, -2);
});
```

3. **Ensure EVPI is always non-negative (mathematical property):**
```typescript
it('never returns negative EVPI', () => {
  // EVPI is mathematically always >= 0
  // Test with various inputs to verify
  const testCases = [
    { mu_L: 0, sigma_L: 0.05, threshold_L: 0 },
    { mu_L: 0.1, sigma_L: 0.01, threshold_L: 0 },
    { mu_L: -0.1, sigma_L: 0.01, threshold_L: 0 },
    { mu_L: 0, sigma_L: 0.001, threshold_L: 0.05 },
  ];

  for (const tc of testCases) {
    const result = calculateEVPI({
      baselineConversionRate: 0.05,
      annualVisitors: 1000000,
      valuePerConversion: 100,
      prior: { mu_L: tc.mu_L, sigma_L: tc.sigma_L },
      threshold_L: tc.threshold_L,
    });
    expect(result.evpiDollars).toBeGreaterThanOrEqual(0);
  }
});
```

4. **Add clamp to ensure non-negative EVPI (defensive):**
In `evpi.ts`, after calculating `evpiDollars`:
```typescript
// EVPI is mathematically non-negative, but floating point errors
// could produce tiny negative values. Clamp to zero.
evpiDollars = Math.max(0, evpiDollars);
```

5. **Run all tests and lint:**
```bash
npm test
npm run lint
```
  </action>
  <verify>
Run `npm test` - all tests pass including new verification tests.
Run `npm run lint` - no lint errors.
Run `npm run build` - builds successfully.
  </verify>
  <done>
- EVPI formula verified against hand calculations
- Both Ship and Don't Ship formulas produce correct results
- EVPI is guaranteed non-negative
- Code is clean and well-documented
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test` - all tests pass (statistics, derived, evpi)
2. `npm run lint` - no lint errors
3. `npm run build` - builds successfully
4. Manual verification: Import calculateEVPI in Node REPL and test with sample values
</verification>

<success_criteria>
- [x] calculateEVPI function implemented and exported
- [x] EVPI formula matches SPEC.md Section 8.4 exactly
- [x] Tests verify formula correctness against hand calculations
- [x] Edge cases (near-zero sigma, one-sided prior) return EVPI near zero
- [x] Both Ship and Don't Ship formulas produce correct results
- [x] All supporting metrics (K, z, phi, Phi, probabilities) are computed
- [x] Edge case flags are set correctly
- [x] EVPI is always non-negative
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculation-engine/03-02-SUMMARY.md`
</output>
