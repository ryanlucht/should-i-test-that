---
phase: 03-calculation-engine
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/hooks/useEVPICalculations.ts
  - src/hooks/useEVPICalculations.test.ts
  - src/lib/calculations/index.ts
autonomous: true

must_haves:
  truths:
    - "Hook returns null when inputs are incomplete"
    - "Hook returns EVPI results when all inputs are valid"
    - "Hook recomputes when any input changes"
    - "Hook correctly derives prior from interval values"
    - "Hook correctly converts threshold units"
  artifacts:
    - path: "src/hooks/useEVPICalculations.ts"
      provides: "React hook connecting store to EVPI calculation"
      exports: ["useEVPICalculations"]
      min_lines: 40
    - path: "src/lib/calculations/index.ts"
      provides: "Barrel export for all calculation modules"
      exports: ["calculateEVPI", "standardNormalPDF", "standardNormalCDF", "deriveK", "normalizeThresholdToLift"]
  key_links:
    - from: "src/hooks/useEVPICalculations.ts"
      to: "src/stores/wizardStore.ts"
      via: "useWizardStore selector"
      pattern: "useWizardStore\\(.*state.*inputs"
    - from: "src/hooks/useEVPICalculations.ts"
      to: "src/lib/calculations/evpi.ts"
      via: "calculateEVPI import"
      pattern: "import.*calculateEVPI"
    - from: "src/hooks/useEVPICalculations.ts"
      to: "src/lib/prior.ts"
      via: "computePriorFromInterval import"
      pattern: "import.*computePriorFromInterval"
---

<objective>
Create a React hook that connects the wizard store to the EVPI calculation engine.

Purpose: This hook is the bridge between user inputs in the store and the pure calculation functions. It handles input validation, unit conversion, and memoization to ensure calculations only run when necessary.

Output: A `useEVPICalculations` hook that returns EVPI results or null if inputs are incomplete.
</objective>

<execution_context>
@/Users/ryan.lucht/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryan.lucht/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-calculation-engine/03-CONTEXT.md
@.planning/phases/03-calculation-engine/03-RESEARCH.md
@.planning/phases/03-calculation-engine/03-01-SUMMARY.md
@.planning/phases/03-calculation-engine/03-02-SUMMARY.md
@src/stores/wizardStore.ts
@src/types/wizard.ts (SharedInputs interface)
@src/lib/prior.ts (computePriorFromInterval, DEFAULT_PRIOR)
@src/lib/calculations/evpi.ts
@src/lib/calculations/derived.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useEVPICalculations hook</name>
  <files>
    src/hooks/useEVPICalculations.ts
    src/lib/calculations/index.ts
  </files>
  <action>
Create the hook that reads from the wizard store and computes EVPI.

First, ensure the barrel export exists. Create/update `src/lib/calculations/index.ts`:
```typescript
/**
 * Calculation Module Exports
 *
 * Barrel file for all EVPI calculation utilities.
 */

export * from './types';
export * from './statistics';
export * from './derived';
export * from './evpi';
```

Create `src/hooks/useEVPICalculations.ts`:

```typescript
/**
 * EVPI Calculations Hook
 *
 * React hook that computes EVPI results from the current wizard store state.
 * Returns null if inputs are incomplete or invalid.
 *
 * Key behaviors:
 * - Reads inputs from Zustand store via selector
 * - Validates all required inputs are present
 * - Derives prior parameters from interval or uses default
 * - Converts threshold to lift units
 * - Memoizes calculation to avoid unnecessary recomputation
 *
 * Per 03-CONTEXT.md: Results section hidden until all inputs are valid.
 */

import { useMemo } from 'react';
import { useWizardStore } from '@/stores/wizardStore';
import { calculateEVPI, normalizeThresholdToLift, deriveK } from '@/lib/calculations';
import { computePriorFromInterval, DEFAULT_PRIOR, DEFAULT_INTERVAL } from '@/lib/prior';
import type { EVPIResults } from '@/lib/calculations/types';

/**
 * Hook that computes EVPI results from current wizard store state.
 *
 * @returns EVPIResults if all inputs are valid, null otherwise
 *
 * @example
 * const results = useEVPICalculations();
 * if (results) {
 *   console.log(`EVPI: $${results.evpiDollars}`);
 *   console.log(`Decision: ${results.defaultDecision}`);
 * }
 */
export function useEVPICalculations(): EVPIResults | null {
  // Select only the shared inputs we need for Basic mode
  const inputs = useWizardStore((state) => state.inputs.shared);

  return useMemo(() => {
    // Validate all required inputs are present
    // Per 03-CONTEXT.md: "Incomplete inputs: Results section hidden"
    if (
      inputs.baselineConversionRate === null ||
      inputs.annualVisitors === null ||
      inputs.valuePerConversion === null ||
      inputs.thresholdScenario === null
    ) {
      return null;
    }

    // For "any-positive" and "minimum-lift" scenarios with custom threshold,
    // we need a threshold value
    if (
      inputs.thresholdScenario !== 'any-positive' &&
      (inputs.thresholdValue === null || inputs.thresholdUnit === null)
    ) {
      return null;
    }

    // Derive prior parameters
    // Per SPEC.md Section 6.2: Use default N(0, 0.05) or compute from interval
    let prior;

    // Determine if using default prior
    // Per STATE.md decision "Derive priorType at validation time":
    // Compare interval values to defaults, don't track as separate UI state
    const isDefaultPrior =
      inputs.priorIntervalLow !== null &&
      inputs.priorIntervalHigh !== null &&
      Math.abs(inputs.priorIntervalLow - DEFAULT_INTERVAL.low) < 0.01 &&
      Math.abs(inputs.priorIntervalHigh - DEFAULT_INTERVAL.high) < 0.01;

    if (isDefaultPrior || inputs.priorIntervalLow === null || inputs.priorIntervalHigh === null) {
      prior = DEFAULT_PRIOR;
    } else {
      prior = computePriorFromInterval(
        inputs.priorIntervalLow,
        inputs.priorIntervalHigh
      );
    }

    // Calculate K first (needed for threshold conversion)
    // K = N_year * CR0 * V
    const K = deriveK(
      inputs.annualVisitors,
      inputs.baselineConversionRate,
      inputs.valuePerConversion
    );

    // Convert threshold to lift units (decimal)
    // Per SPEC.md Section 7.3: Handle different threshold scenarios
    let threshold_L: number;

    if (inputs.thresholdScenario === 'any-positive') {
      // T_L = 0 for "ship any positive impact"
      threshold_L = 0;
    } else if (inputs.thresholdUnit === null || inputs.thresholdValue === null) {
      // Should not reach here due to validation above, but defensive
      return null;
    } else {
      // For "minimum-lift" and "accept-loss" scenarios
      // Note: thresholdValue is already negative for "accept-loss" (per 02-03 sign convention)
      threshold_L = normalizeThresholdToLift(
        inputs.thresholdValue,
        inputs.thresholdUnit,
        K
      );
    }

    // Calculate EVPI
    return calculateEVPI({
      baselineConversionRate: inputs.baselineConversionRate,
      annualVisitors: inputs.annualVisitors,
      valuePerConversion: inputs.valuePerConversion,
      prior,
      threshold_L,
    });
  }, [
    inputs.baselineConversionRate,
    inputs.annualVisitors,
    inputs.valuePerConversion,
    inputs.priorIntervalLow,
    inputs.priorIntervalHigh,
    inputs.thresholdScenario,
    inputs.thresholdUnit,
    inputs.thresholdValue,
  ]);
}
```

Note: Per 03-RESEARCH.md pitfall #6, we explicitly list all input fields in the useMemo dependencies to avoid stale results.
  </action>
  <verify>
Run `npm run lint` - no lint errors.
Run `npm run build` - builds successfully.
  </verify>
  <done>
- useEVPICalculations hook created
- Returns null when inputs incomplete
- Derives prior from interval values
- Converts threshold to lift units
- All dependencies explicitly listed in useMemo
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hook tests</name>
  <files>
    src/hooks/useEVPICalculations.test.ts
  </files>
  <action>
Create tests for the hook using React Testing Library's renderHook.

Create `src/hooks/useEVPICalculations.test.ts`:

```typescript
/**
 * Tests for useEVPICalculations hook
 */

import { renderHook, act } from '@testing-library/react';
import { useEVPICalculations } from './useEVPICalculations';
import { useWizardStore } from '@/stores/wizardStore';

// Reset store before each test
beforeEach(() => {
  const { resetWizard } = useWizardStore.getState();
  resetWizard();
});

describe('useEVPICalculations', () => {
  describe('when inputs are incomplete', () => {
    it('returns null when no inputs are set', () => {
      const { result } = renderHook(() => useEVPICalculations());
      expect(result.current).toBeNull();
    });

    it('returns null when only some business inputs are set', () => {
      const { setSharedInput } = useWizardStore.getState();

      act(() => {
        setSharedInput('baselineConversionRate', 0.05);
        setSharedInput('annualVisitors', 1000000);
        // valuePerConversion not set
      });

      const { result } = renderHook(() => useEVPICalculations());
      expect(result.current).toBeNull();
    });

    it('returns null when threshold scenario not selected', () => {
      const { setSharedInput } = useWizardStore.getState();

      act(() => {
        setSharedInput('baselineConversionRate', 0.05);
        setSharedInput('annualVisitors', 1000000);
        setSharedInput('valuePerConversion', 100);
        setSharedInput('priorIntervalLow', -8.22);
        setSharedInput('priorIntervalHigh', 8.22);
        // thresholdScenario not set
      });

      const { result } = renderHook(() => useEVPICalculations());
      expect(result.current).toBeNull();
    });

    it('returns null when minimum-lift selected but no threshold value', () => {
      const { setSharedInput } = useWizardStore.getState();

      act(() => {
        setSharedInput('baselineConversionRate', 0.05);
        setSharedInput('annualVisitors', 1000000);
        setSharedInput('valuePerConversion', 100);
        setSharedInput('priorIntervalLow', -8.22);
        setSharedInput('priorIntervalHigh', 8.22);
        setSharedInput('thresholdScenario', 'minimum-lift');
        // thresholdValue and thresholdUnit not set
      });

      const { result } = renderHook(() => useEVPICalculations());
      expect(result.current).toBeNull();
    });
  });

  describe('when all inputs are valid', () => {
    const setupValidInputs = () => {
      const { setSharedInput } = useWizardStore.getState();
      setSharedInput('baselineConversionRate', 0.05);
      setSharedInput('annualVisitors', 1000000);
      setSharedInput('valuePerConversion', 100);
      setSharedInput('priorIntervalLow', -8.22);
      setSharedInput('priorIntervalHigh', 8.22);
      setSharedInput('thresholdScenario', 'any-positive');
    };

    it('returns EVPI results for any-positive threshold', () => {
      act(() => {
        setupValidInputs();
      });

      const { result } = renderHook(() => useEVPICalculations());

      expect(result.current).not.toBeNull();
      expect(result.current!.evpiDollars).toBeGreaterThan(0);
      expect(result.current!.defaultDecision).toBe('ship');
      expect(result.current!.K).toBe(5000000);
    });

    it('returns EVPI results for minimum-lift threshold in lift units', () => {
      act(() => {
        setupValidInputs();
        const { setSharedInput } = useWizardStore.getState();
        setSharedInput('thresholdScenario', 'minimum-lift');
        setSharedInput('thresholdUnit', 'lift');
        setSharedInput('thresholdValue', 5); // 5% lift
      });

      const { result } = renderHook(() => useEVPICalculations());

      expect(result.current).not.toBeNull();
      // threshold_L = 0.05 (5% as decimal)
      expect(result.current!.threshold_dollars).toBeCloseTo(250000, -2);
    });

    it('returns EVPI results for minimum-lift threshold in dollars', () => {
      act(() => {
        setupValidInputs();
        const { setSharedInput } = useWizardStore.getState();
        setSharedInput('thresholdScenario', 'minimum-lift');
        setSharedInput('thresholdUnit', 'dollars');
        setSharedInput('thresholdValue', 100000); // $100K
      });

      const { result } = renderHook(() => useEVPICalculations());

      expect(result.current).not.toBeNull();
      // T_L = 100000 / 5000000 = 0.02 (2% lift)
      expect(result.current!.threshold_dollars).toBeCloseTo(100000, -2);
    });

    it('returns EVPI results for accept-loss threshold (negative)', () => {
      act(() => {
        setupValidInputs();
        const { setSharedInput } = useWizardStore.getState();
        setSharedInput('thresholdScenario', 'accept-loss');
        setSharedInput('thresholdUnit', 'lift');
        setSharedInput('thresholdValue', -5); // -5% lift (stored negative per sign convention)
      });

      const { result } = renderHook(() => useEVPICalculations());

      expect(result.current).not.toBeNull();
      // threshold_L = -0.05 (negative)
      expect(result.current!.threshold_dollars).toBeCloseTo(-250000, -2);
    });
  });

  describe('prior derivation', () => {
    const setupBusinessInputs = () => {
      const { setSharedInput } = useWizardStore.getState();
      setSharedInput('baselineConversionRate', 0.05);
      setSharedInput('annualVisitors', 1000000);
      setSharedInput('valuePerConversion', 100);
      setSharedInput('thresholdScenario', 'any-positive');
    };

    it('uses default prior when interval matches defaults', () => {
      act(() => {
        setupBusinessInputs();
        const { setSharedInput } = useWizardStore.getState();
        setSharedInput('priorIntervalLow', -8.22);
        setSharedInput('priorIntervalHigh', 8.22);
      });

      const { result } = renderHook(() => useEVPICalculations());

      expect(result.current).not.toBeNull();
      // Default prior: N(0, 0.05)
      // With z=0 and threshold=0, we expect specific values
      expect(result.current!.zScore).toBeCloseTo(0, 4);
    });

    it('computes custom prior from asymmetric interval', () => {
      act(() => {
        setupBusinessInputs();
        const { setSharedInput } = useWizardStore.getState();
        setSharedInput('priorIntervalLow', -5);  // -5%
        setSharedInput('priorIntervalHigh', 15); // +15%
      });

      const { result } = renderHook(() => useEVPICalculations());

      expect(result.current).not.toBeNull();
      // Custom prior: mu_L = (-.05 + .15)/2 = 0.05
      // z = (0 - 0.05) / sigma = negative (threshold below mean)
      expect(result.current!.zScore).toBeLessThan(0);
    });
  });

  describe('reactivity', () => {
    it('recomputes when inputs change', () => {
      const { setSharedInput } = useWizardStore.getState();

      // Setup initial valid state
      act(() => {
        setSharedInput('baselineConversionRate', 0.05);
        setSharedInput('annualVisitors', 1000000);
        setSharedInput('valuePerConversion', 100);
        setSharedInput('priorIntervalLow', -8.22);
        setSharedInput('priorIntervalHigh', 8.22);
        setSharedInput('thresholdScenario', 'any-positive');
      });

      const { result, rerender } = renderHook(() => useEVPICalculations());
      const initialEVPI = result.current!.evpiDollars;

      // Change value per conversion
      act(() => {
        setSharedInput('valuePerConversion', 200);
      });
      rerender();

      // EVPI should increase (higher K)
      expect(result.current!.evpiDollars).toBeGreaterThan(initialEVPI);
      expect(result.current!.K).toBe(10000000); // doubled
    });
  });
});
```

Note: Tests use `act()` for state updates and verify both null returns for incomplete inputs and correct calculations for valid inputs.
  </action>
  <verify>
Run `npm test src/hooks/useEVPICalculations.test.ts` - all tests pass.
  </verify>
  <done>
- Tests verify null return for incomplete inputs
- Tests verify EVPI calculation for valid inputs
- Tests verify threshold unit conversion (lift and dollars)
- Tests verify prior derivation (default and custom)
- Tests verify reactivity when inputs change
  </done>
</task>

<task type="auto">
  <name>Task 3: Final verification and cleanup</name>
  <files>
    src/lib/calculations/index.ts
    src/hooks/useEVPICalculations.ts
  </files>
  <action>
Run full test suite and verify everything is properly integrated.

1. **Run all tests:**
```bash
npm test
```

2. **Run lint:**
```bash
npm run lint
```

3. **Run build:**
```bash
npm run build
```

4. **Verify exports are accessible:**
Create a simple verification script or use Node REPL to confirm:
- `import { calculateEVPI } from '@/lib/calculations'` works
- `import { useEVPICalculations } from '@/hooks/useEVPICalculations'` works

5. **Update any import paths if needed:**
Ensure the barrel export in `src/lib/calculations/index.ts` is complete and exports all necessary items.

6. **Add JSDoc to hook export:**
Ensure the hook has clear documentation for consumers.
  </action>
  <verify>
Run `npm test` - all tests pass (should be ~40+ test cases now).
Run `npm run lint` - no lint errors.
Run `npm run build` - builds successfully.
  </verify>
  <done>
- All tests pass
- All exports are properly accessible
- Build completes successfully
- Code is ready for Phase 4 (Visualization & Results) to consume
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test` - all tests pass (statistics, derived, evpi, useEVPICalculations)
2. `npm run lint` - no lint errors
3. `npm run build` - builds successfully
4. Hook can be imported and used in components
5. Results are null until all inputs are filled
</verification>

<success_criteria>
- [x] useEVPICalculations hook created and exported
- [x] Hook returns null for incomplete inputs
- [x] Hook computes EVPI correctly for all threshold scenarios
- [x] Hook derives prior from interval values or uses default
- [x] Hook converts threshold units correctly (dollars/lift)
- [x] Hook recomputes when inputs change (memoization works)
- [x] All tests pass
- [x] Ready for Phase 4 to consume results
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculation-engine/03-03-SUMMARY.md`
</output>
